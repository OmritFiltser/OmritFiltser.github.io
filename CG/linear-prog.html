<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>יחידה 4 תכנון ליניארי וחיתוך של חצאי מישורים | גאומטריה חישובית</title>
<meta name="author" content="ד’’ר עומרית פילצר">
<meta name="description" content="4.1 הקדמה  4.1.1 בעיית הייצור באמצעות תבניות  חפצים רבים שאנו משתמשים בהם באופן יום-יומי מיוצרים בתהליך אוטומטי, שבו יוצקים נוזל לתבנית רב פעמית, ולאחר שהוא מתמצק שולפים אותו החוצה מבלי לפגוע...">
<meta name="generator" content="bookdown 0.34 with bs4_book()">
<meta property="og:title" content="יחידה 4 תכנון ליניארי וחיתוך של חצאי מישורים | גאומטריה חישובית">
<meta property="og:type" content="book">
<meta property="og:url" content="https://omrit.filtser.com/CG/linear-prog.html">
<meta property="og:description" content="4.1 הקדמה  4.1.1 בעיית הייצור באמצעות תבניות  חפצים רבים שאנו משתמשים בהם באופן יום-יומי מיוצרים בתהליך אוטומטי, שבו יוצקים נוזל לתבנית רב פעמית, ולאחר שהוא מתמצק שולפים אותו החוצה מבלי לפגוע...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="יחידה 4 תכנון ליניארי וחיתוך של חצאי מישורים | גאומטריה חישובית">
<meta name="twitter:description" content="4.1 הקדמה  4.1.1 בעיית הייצור באמצעות תבניות  חפצים רבים שאנו משתמשים בהם באופן יום-יומי מיוצרים בתהליך אוטומטי, שבו יוצקים נוזל לתבנית רב פעמית, ולאחר שהוא מתמצק שולפים אותו החוצה מבלי לפגוע...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.5.0/transition.js"></script><script src="libs/bs3compat-0.5.0/tabs.js"></script><script src="libs/bs3compat-0.5.0/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<link rel="stylesheet" href="style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row no-pad">
  <header class="col-sm-12 col-lg-2 sidebar sidebar-book border-left"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">גאומטריה חישובית</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search" dir="rtl">
        <input id="search" class="form-control" type="search" placeholder="חיפוש" aria-label="Search" dir="rtl">
</form>

      <nav aria-label="Table of contents"><h2>יחידות הלימוד:</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">ברוכים הבאים</a></li>
<li><a class="" href="intro.html"><span class="header-section-number">1</span> מבוא</a></li>
<li><a class="" href="map-overlay.html"><span class="header-section-number">2</span> מפות מישוריות וטכניקת הישר הסורק</a></li>
<li><a class="" href="pol-tringle.html"><span class="header-section-number">3</span> שילושי פוליגונים ובעיית הגלריה לאמנות</a></li>
<li><a class="active" href="linear-prog.html"><span class="header-section-number">4</span> תכנון ליניארי וחיתוך של חצאי מישורים</a></li>
<li><a class="" href="orthogonal-range-seach.html"><span class="header-section-number">5</span> חיפוש בתחומים אורתוגונלים</a></li>
<li><a class="" href="point-location.html"><span class="header-section-number">6</span> מיקום נקודה ומפה טרפזית</a></li>
<li><a class="" href="voronoi.html"><span class="header-section-number">7</span> דיאגרמת וורונוי</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="linear-prog" class="section level1" number="4">
<h1>
<span class="header-section-number">יחידה 4</span> תכנון ליניארי וחיתוך של חצאי מישורים<a class="anchor" aria-label="anchor" href="#linear-prog"><i class="fas fa-link"></i></a>
</h1>
<div id="preface" class="section level2" number="4.1">
<h2>
<span class="header-section-number">4.1</span> הקדמה<a class="anchor" aria-label="anchor" href="#preface"><i class="fas fa-link"></i></a>
</h2>
<div id="molding-prob" class="section level3" number="4.1.1">
<h3>
<span class="header-section-number">4.1.1</span> בעיית הייצור באמצעות תבניות<a class="anchor" aria-label="anchor" href="#molding-prob"><i class="fas fa-link"></i></a>
</h3>
<p><img src="images/4/molding-casting.jpg" align="left" width="33%"> חפצים רבים שאנו משתמשים בהם באופן יום-יומי מיוצרים בתהליך אוטומטי, שבו יוצקים נוזל לתבנית רב פעמית, ולאחר שהוא מתמצק שולפים אותו החוצה מבלי לפגוע בתבנית. כמובן שלא כל צורה תלת מימדית ניתנת לייצור באופן הזה, למשל צורה שהיא כדורית. נניח שנתון לנו <strong>פוליהדרון</strong> (גוף תלת מימדי המורכב מפאות שהן פוליגונים, צלעות שהן קוים ישרים, וקודקודים שהם נקודות), איך נדע האם ניתן לייצר אותו על ידי יציקה לתבנית רב פעמית?</p>
<div id="קראו-את-ההקדמה-לפרק-4-עמודים-63-64." class="section level4 unnumbered">
<h4>קראו את ההקדמה לפרק 4 (עמודים 63-64).<a class="anchor" aria-label="anchor" href="#%D7%A7%D7%A8%D7%90%D7%95-%D7%90%D7%AA-%D7%94%D7%94%D7%A7%D7%93%D7%9E%D7%94-%D7%9C%D7%A4%D7%A8%D7%A7-4-%D7%A2%D7%9E%D7%95%D7%93%D7%99%D7%9D-63-64."><i class="fas fa-link"></i></a>
</h4>
</div>
</div>
<div id="geom-model" class="section level3" number="4.1.2">
<h3>
<span class="header-section-number">4.1.2</span> מודל גאומטרי לבעיה<a class="anchor" aria-label="anchor" href="#geom-model"><i class="fas fa-link"></i></a>
</h3>
<p><img src="images/4/mold.jpg" align="left" width="25%"> בהינתן פוליהדרון <span class="math inline">\(P\)</span> בעל <span class="math inline">\(n\)</span> פאות שהן פוליגונים, נרצה לתכנן תבנית שתאפשר לנו לייצר את <span class="math inline">\(P\)</span>. כדי שנוכל לחלץ את <span class="math inline">\(P\)</span> מהתבנית על ידי משיכה בכיוון אחד, נדרוש שבדיוק אחת מהפאות של <span class="math inline">\(P\)</span> תהיה מוכלת בפאה העליונה של התבנית. התבנית חייבת להתאים לצורה של <span class="math inline">\(P\)</span>, אבל את הפאה העליונה נוכל לבחור מתוך <span class="math inline">\(n\)</span> הפאות של <span class="math inline">\(P\)</span>, ולכן יש לכל היותר <span class="math inline">\(n\)</span> תבניות אפשרויות. כמובן שלא כל תבנית תאפשר לנו לחלץ את <span class="math inline">\(P\)</span>.</p>
<div class="rmdwarning">
<div class="inline-figure">
<img src="images/question.png" align="right" width="10%" style="padding:0px 0px 0px 10px"> בדיקת שפיות! ענו על השאלה הבאה: באילו מהתבניות הבאות ניתן לחלץ את הפוליהדרון שיצקו בהן על ידי משיכה בכיוון אחד?</div>
<p>(לשם הפשטות, האיורים מציגים חתך עומק של התבנית והפוליהדרון בדו-מימד. הניחו שכל חתכי העומק של הפוליהדרון זהים לזה שבאיור.)</p>
<p><img src="images/4/mold1.jpg" width="20%"><img src="images/4/mold2.jpg" width="20%"><img src="images/4/mold3.jpg" width="20%"><img src="images/4/mold4.jpg" width="20%"><img src="images/4/mold5.jpg" width="20%"></p>
<details><summary>
(פתרון)
</summary><p>שלושת התבניות הראשונות משמאל.</p>
</details>
</div>
<p>אובייקט שניתן לייצור על ידי יציקה לתבנית רב פעמית נקרא castable. כדי לבדוק האם <span class="math inline">\(P\)</span> הוא castable, נבדוק את כל האפשרויות לתבנית עבורו. בהינתן אחת מהאפשרויות האלה (כלומר, בהינתן הפאה של <span class="math inline">\(P\)</span> שתהיה מוכלת בפאה העליונה של התבנית), נרצה לקבוע האם קיים כיוון (וקטור) <span class="math inline">\(\overrightarrow{d}\)</span> כך שניתן לשלוף את <span class="math inline">\(P\)</span> מהתבנית על ידי משיכה בכיוון <span class="math inline">\(\overrightarrow{d}\)</span>.</p>
<p><img src="images/4/angle.jpg" align="left" width="33%"> שימו לב שלכל פאה <span class="math inline">\(f\)</span> של <span class="math inline">\(P\)</span> שהיא לא הפאה העליונה, יש פאה מתאימה <span class="math inline">\(\hat{f}\)</span> בתבנית. באופן אינטואיטיבי, כדי שנוכל להוציא את <span class="math inline">\(P\)</span> מהתבנית, כל פאה <span class="math inline">\(f\)</span> של <span class="math inline">\(P\)</span> צריכה לנוע בכיוון שהוא “נגדי” או לכל היותר “מאונך” ל-<span class="math inline">\(\hat{f}\)</span>. באופן פורמלי, נוכל להסתכל על הנורמל (כלפי חוץ מהפוליגון) של פאה <span class="math inline">\(f\)</span>, נסמן אותו <span class="math inline">\(\overrightarrow{\mu}( f )\)</span>. הנורמל של <span class="math inline">\(f\)</span> הוא וקטור המאונך למישור המכיל את <span class="math inline">\(f\)</span>. נוכל להראות שהפאה המתאימה <span class="math inline">\(\hat{f}\)</span> של התבנית, מאפשרת תנועה רק בכיוון <span class="math inline">\(\overrightarrow{d}\)</span> שבו הזווית (הקטנה) שנוצרת בין <span class="math inline">\(\overrightarrow{d}\)</span> ל-<span class="math inline">\(\overrightarrow{\mu}( f )\)</span> היא לפחות <span class="math inline">\(90 ^\circ\)</span>.</p>
<p>הטענה הזו מובילה להגדרת הבעיה באופן הבא: יש למצוא כיוון <span class="math inline">\(\overrightarrow{d}\)</span> כך שהזוית שלו עם הנורמלים של כל אחת מהפאות של <span class="math inline">\(P\)</span> היא לפחות <span class="math inline">\(90 ^\circ\)</span>. כל פאה של P בעצם מהווה אילוץ על הכיוון <span class="math inline">\(\overrightarrow{d}\)</span>. כל אילוץ כזה ניתן לתאר ע”י משוואה לינארית: הזוית בין <span class="math inline">\(\overrightarrow{d}\)</span> ל-<span class="math inline">\(\overrightarrow{\mu}( f )\)</span> גדולה או שווה ל-<span class="math inline">\(90 ^\circ\)</span> אם ורק אם <span class="math inline">\(\overrightarrow{d} \cdot \overrightarrow{\mu}( f ) \le 0\)</span>. נוכל לייצג את <span class="math inline">\(\overrightarrow{d}\)</span> על ידי נקודה במישור <span class="math inline">\(z = 1\)</span>, כלומר, <span class="math inline">\(\overrightarrow{d}\)</span> יהיה הוקטור <span class="math inline">\((x,y,1)\)</span> מתחיל בראשית הצירים ומסתיים בנקודה <span class="math inline">\((x, y, 1 )\)</span>. לכן עבור <span class="math inline">\(\overrightarrow{\mu}( f ) =( \mu_x, \mu_y, \mu_z )\)</span> נקבל אילוץ שהוא בעצם משוואה של חצי מישור: <span class="math inline">\(\mu_x \cdot x + \mu_y \cdot y + \mu_z \le 0\)</span>.</p>
<p>המשמעות היא שקיים כיוון <span class="math inline">\(\overrightarrow{d}\)</span> המאפשר לשלוף את <span class="math inline">\(P\)</span> מהתבנית, אם ורק אם קיימת נקודה <span class="math inline">\(( x, y )\)</span> המקיימת כל כל האילוצים, כלומר, נקודה שנמצאת בחיתוך של אוסף חצאי המישורים המתאימים להם. בעצם המרנו את הבעיה המקורית לבעיה גאומטרית במישור: בהינתן אוסף של n חצאי מישורים, יש למצוא נקודה בחיתוך שלהם, אם החיתוך לא ריק. בהמשך נראה כיצד ניתן לפתור את הבעיה הזו בזמן צפוי <span class="math inline">\(O ( n )\)</span>, ולכן נוכל לפתור את בעיית הייצור באמצעות תבניות בזמן צפוי <span class="math inline">\(O ( n^2 )\)</span>.</p>
<div id="קראו-את-סעיף-4.1-בספר-עמודים-64-66." class="section level4 unnumbered">
<h4>קראו את סעיף 4.1 בספר (עמודים 64-66).<a class="anchor" aria-label="anchor" href="#%D7%A7%D7%A8%D7%90%D7%95-%D7%90%D7%AA-%D7%A1%D7%A2%D7%99%D7%A3-4.1-%D7%91%D7%A1%D7%A4%D7%A8-%D7%A2%D7%9E%D7%95%D7%93%D7%99%D7%9D-64-66."><i class="fas fa-link"></i></a>
</h4>
<hr class="mt-5 mb-5">
</div>
</div>
</div>
<div id="line-int" class="section level2" number="4.2">
<h2>
<span class="header-section-number">4.2</span> חיתוך של חצאי מישורים<a class="anchor" aria-label="anchor" href="#line-int"><i class="fas fa-link"></i></a>
</h2>
<div id="div-con-alg" class="section level3" number="4.2.1">
<h3>
<span class="header-section-number">4.2.1</span> אלגוריתם בשיטת הפרד ומשול<a class="anchor" aria-label="anchor" href="#div-con-alg"><i class="fas fa-link"></i></a>
</h3>
<p>בחלק הקודם ראינו כיצד ניתן להמיר את הבעיה של ייצור באמצעות תבניות לבעיה של מציאת נקודה כלשהי המספקת אוסף של אילוצים לינאריים בשני משתנים, או לחילופין, לבעיה הגאומטרית של מציאת נקודה כלשהי בחיתוך של אוסף חצאי מישורים. החיתוך של אוסף חצאי מישורים הוא תחום קמור, אך הוא אינו חייב להיות חסום. הנה דוגמה לתחום קמור שאינו חסום (מימין), ותחום קמור חסום (משמאל).</p>
<p align="center" width="100%">
</p>
<div class="inline-figure"><img src="images/4/bounded_and_unbounded.jpg" width="70%"></div>

<p>לפני שנדבר על הבעיה של מציאת נקודה כלשהי בחיתוך, נראה קודם כיצד ניתן למצוא את קבוצת כל הנקודות בחיתוך. בחלקו הראשון של סעיף 4.2 בספר הלימוד תקראו על אלגוריתם IntersectHalfPlanes, המקבל כקלט אוסף <span class="math inline">\(H\)</span> של חצאי מישורים, ומחשב את התחום הקמור שהוא החיתוך שלהם. זהו אלגוריתם הפועל בשיטת הפרד ומשול: הוא מחלק את הקבוצה <span class="math inline">\(H\)</span> באופן שרירותי לשתי קבוצות, מחשב את החיתוך של כל אחת מהן באופן רקורסיבי, ולאחר מכן מחשב את החיתוך של שני התחומים הקמורים שהתקבלו בעזרת פרוצדורה נוספת בשם IntesectConvexRegions.</p>
<p>את אלגוריתם IntersectConvexRegions לחישוב החיתוך בין תחומים קמורים נתאר בהמשך החלק הזה.</p>
<div id="קראו-את-חלקו-הראשון-של-סעיף-4.2-בספר-הלימוד-עמודים-6668." class="section level4 unnumbered">
<h4>קראו את חלקו הראשון של סעיף 4.2 בספר הלימוד (עמודים 66–68).<a class="anchor" aria-label="anchor" href="#%D7%A7%D7%A8%D7%90%D7%95-%D7%90%D7%AA-%D7%97%D7%9C%D7%A7%D7%95-%D7%94%D7%A8%D7%90%D7%A9%D7%95%D7%9F-%D7%A9%D7%9C-%D7%A1%D7%A2%D7%99%D7%A3-4.2-%D7%91%D7%A1%D7%A4%D7%A8-%D7%94%D7%9C%D7%99%D7%9E%D7%95%D7%93-%D7%A2%D7%9E%D7%95%D7%93%D7%99%D7%9D-6668."><i class="fas fa-link"></i></a>
</h4>
</div>
</div>
<div id="convex-int" class="section level3" number="4.2.2">
<h3>
<span class="header-section-number">4.2.2</span> חיתוך של פוליגונים קמורים<a class="anchor" aria-label="anchor" href="#convex-int"><i class="fas fa-link"></i></a>
</h3>
<p>בחלק השלישי של יחידה 2 (המדבר על פעולות בוליאניות), ראינו שניתן לחשב את החיתוך של שני פוליגונים (לא בהכרח קמורים) בזמן O ( ( n + k ) log n ), כאשר k הוא מספר נקודות חיתוך, בעזרת האלגוריתם MapOverlay.</p>
<div class="rmdwarning">
<p><img src="images/question.png" align="right" width="10%" style="padding:0px 0px 0px 10px"><img src="images/4/question.jpg" align="left" width="30%"> מהו המספר המקסימלי האפשרי של נקודות חיתוך בין צלעות של שני פוליגונים קמורים בעלי <span class="math inline">\(n\)</span> קודקודים כל אחד? נסו לצייר שני פוליגונים קמורים עם מספר מקסימלי של נקודות חיתוך.</p>
<details><summary>
(פתרון)
</summary><p>המספר המקסימלי האפשרי של נקודות חיתוך בין שני פוליגונים קמורים <span class="math inline">\(C_1\)</span> ו-<span class="math inline">\(C_2\)</span> בעלי
<span class="math inline">\(n\)</span> נקודות כל אחד, הוא
<span class="math inline">\(2 n\)</span>. הסיבה היא שכל צלע <span class="math inline">\(e\)</span> של <span class="math inline">\(C_1\)</span> יכולה להחתך עם לכל היותר שתי צלעות של <span class="math inline">\(C_2\)</span>: אם <span class="math inline">\(e\)</span> היתה נחתכת עם יותר משתי צלעות של <span class="math inline">\(C_2\)</span>, אז <span class="math inline">\(C_2\)</span> לא היה יכול להיות קמור.</p>
<p align="center" width="100%">
</p>
<div class="inline-figure"><img src="images/4/convex_intersection.jpg" width="40%"></div>

<p>הנה דוגמה למשפחה של זוגות פוליגונים קמורים <span class="math inline">\(C_1\)</span> ו-<span class="math inline">\(C_2\)</span> כך שכל צלע של <span class="math inline">\(C_1\)</span> נחתכת עם בדיוק שתי צלעות של <span class="math inline">\(C_2\)</span>: אלו זוגות של פוליגונים משוכללים בעלי <span class="math inline">\(n\)</span> צלעות המסובבים בזוית שונה שונה סביב המרכז.</p>
<p align="center" width="100%">
</p>
<div class="inline-figure"><img src="images/4/max_convex_intersection.jpg" width="70%"></div>

</details>
</div>
<p>אם נשתמש באלגוריתם MapOverlay עבור מציאת החיתוך בין פוליגונים קמורים, זמן הריצה יהיה <span class="math inline">\(O ( n \log n )\)</span>, כי כמו שראינו בשאלה למעלה, <span class="math inline">\(k \le 2 n\)</span>. לכן, לפי שיטת האב (Master Theorem), זמן הריצה הכולל עבור אלגוריתם IntersectHalfPlanes יהיה <span class="math inline">\(O ( n \log^2 n )\)</span>. האם בכל זאת ניתן לחשב את החיתוך באופן יעיל יותר עבור תחומים קמורים? התשובה היא כן! (זכרו שתמיד נשאף לזמן ריצה לינארי, או <span class="math inline">\(O ( n \log n )\)</span>…)</p>
<p>אלגוריתם MapOverlay משתמש בשיטת הישר הסורק, ולזמן הריצה שלו יש שני גורמים. הגורם הראשון הוא <span class="math inline">\(( n + k )\)</span> – מספר המאורעות. הגורם השני הוא <span class="math inline">\(\log n\)</span> – הזמן לטיפול במאורע, כלומר, עדכון הסטטוס (שיכול להכיל <span class="math inline">\(O ( n )\)</span> קטעים), והוספת מאורע לתור המאורעות בכל פעם שמצאנו נקודת חיתוך. אך האם זהו המצב גם עבור פוליגונים קמורים?</p>
<p>למעשה, עבור פוליגונים קמורים יהיו לכל היותר 4 צלעות שחותכות את הישר הסורק בכל רגע נתון. נוכל לראות זאת אם נחלק כל פוליגון לשרשרת ימנית ושרשרת שמאלית (מהקודקד הגבוה ביותר לקודקוד הנמוך ביותר). כל שרשרת כזאת היא <span class="math inline">\(y\)</span>-מונוטונית, ולכן חותכת את הישר הסורק (האופקי) פעם אחת בלבד.</p>
<p align="center" width="100%">
</p>
<div class="inline-figure"><img src="images/4/convex_intersection_left_right.jpg" width="70%"></div>

<p>עובדה זו מובילה לכך שהטיפול בכל מאורע יתבצע בזמן קבוע, וכבר לא יהיה לנו צורך במאורעות שהם נקודות חיתוך. באופן זה נקבל אלגוריתם למציאת חיתוך של פוליגונים קמורים עם זמן ריצה של <span class="math inline">\(O ( n )\)</span> בלבד, ובכך נשפר את זמן הריצה עבור חיתוך חצאי מישורים ל-<span class="math inline">\(O ( n \log n )\)</span>.</p>
<div id="קראו-את-חלקו-השני-של-סעיף-4.2-בספר-הלימוד-עמודים-7168." class="section level4 unnumbered">
<h4>קראו את חלקו השני של סעיף 4.2 בספר הלימוד (עמודים 71–68).<a class="anchor" aria-label="anchor" href="#%D7%A7%D7%A8%D7%90%D7%95-%D7%90%D7%AA-%D7%97%D7%9C%D7%A7%D7%95-%D7%94%D7%A9%D7%A0%D7%99-%D7%A9%D7%9C-%D7%A1%D7%A2%D7%99%D7%A3-4.2-%D7%91%D7%A1%D7%A4%D7%A8-%D7%94%D7%9C%D7%99%D7%9E%D7%95%D7%93-%D7%A2%D7%9E%D7%95%D7%93%D7%99%D7%9D-7168."><i class="fas fa-link"></i></a>
</h4>
<hr class="mt-5 mb-5">
</div>
</div>
</div>
<div id="planar-LP" class="section level2" number="4.3">
<h2>
<span class="header-section-number">4.3</span> תכנון לינארי במישור<a class="anchor" aria-label="anchor" href="#planar-LP"><i class="fas fa-link"></i></a>
</h2>
<div id="what-is-LP" class="section level3" number="4.3.1">
<h3>
<span class="header-section-number">4.3.1</span> מהו תכנון לינארי?<a class="anchor" aria-label="anchor" href="#what-is-LP"><i class="fas fa-link"></i></a>
</h3>
<p>תכנון לינארי היא בעיית אופטימיזציה של ביטוי לינארי, תחת אוסף של אילוצים לינאריים. זוהי בעייה מרכזית בתחום של חקר ביצועים, שבו בעיות אופטימיזציה רבות ניתנות לתאור באמצעות תוכנית לינארית. הבעיה צברה פופולריות רבה משום שהיא שימושית בתחומים רבים נוספים, ולכן במשך השנים נעשו מאמצים רבים למציאת פתרונות יעילים ומהירים עבורה. בסרטון הבא נראה דוגמה לתוכנית כזאת, נזכיר חלק מהכלים הקיימים כיום לפתרון בעיות תכנון לינארי, ונדבר על הקשר בין תכנון לינארי במישור לבעיית החיתוך של חצאי מישורים.</p>
<div id="צפו-בסרטון-הבא-3" class="section level4 unnumbered">
<h4>צפו בסרטון הבא:<a class="anchor" aria-label="anchor" href="#%D7%A6%D7%A4%D7%95-%D7%91%D7%A1%D7%A8%D7%98%D7%95%D7%9F-%D7%94%D7%91%D7%90-3"><i class="fas fa-link"></i></a>
</h4>
<iframe width="560" height="315" src="https://www.youtube.com/embed/r5vnvtTYiEY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
</div>
<div id="קראו-את-חלקו-הראשון-של-סעיף-4.3-בספר-הלימוד-עמודים-7172." class="section level4 unnumbered">
<h4>קראו את חלקו הראשון של סעיף 4.3 בספר הלימוד (עמודים 71–72).<a class="anchor" aria-label="anchor" href="#%D7%A7%D7%A8%D7%90%D7%95-%D7%90%D7%AA-%D7%97%D7%9C%D7%A7%D7%95-%D7%94%D7%A8%D7%90%D7%A9%D7%95%D7%9F-%D7%A9%D7%9C-%D7%A1%D7%A2%D7%99%D7%A3-4.3-%D7%91%D7%A1%D7%A4%D7%A8-%D7%94%D7%9C%D7%99%D7%9E%D7%95%D7%93-%D7%A2%D7%9E%D7%95%D7%93%D7%99%D7%9D-7172."><i class="fas fa-link"></i></a>
</h4>
</div>
</div>
<div id="inc-alg" class="section level3" number="4.3.2">
<h3>
<span class="header-section-number">4.3.2</span> אלגוריתם אינקרמנטלי<a class="anchor" aria-label="anchor" href="#inc-alg"><i class="fas fa-link"></i></a>
</h3>
<p>בחלקו השני של סעיף 4.3 בספר הלימוד מתואר אלגוריתם אינקרמנטלי בשם 2DBoundedLP, לפתרון של תוכנית לינארית בשני מימדים. האלגוריתם פועל תחת ההנחה שהתוכנית הלינארית חסומה. לכן, בשלב הזה נניח כי ניתן למצוא ולהוסיף לתוכנית הלינארית שני חצאי מישורים <span class="math inline">\(m_1, m_2\)</span>, שיגרמו לכך שהתוכנית תהיה חסומה בכיוון <span class="math inline">\(\overrightarrow{c}\)</span>, אך לא ישנו את הפתרון האופטימלי במקרה שבו התוכנית חסומה. בהמשך נראה כיצד להימנע מהנחה זו ולקבוע מראש האם התוכנית חסומה או לא.</p>
<p>האלגוריתם האינקרמנטלי מתחיל מפתרון עבור <span class="math inline">\(C_0 = m_1 \cap m_2\)</span>, ואז מוסיף את יתר חצאי המישורים <span class="math inline">\(h_1, \dots, h_n\)</span> לפי הסדר. בשלב ה-<span class="math inline">\(i\)</span>, האלגוריתם ימצא קודקוד v_i שהוא הנקודה שממקסמת את פונקציית המטרה בחיתוך <span class="math inline">\(C_i = m_1 \cap m_2 \cap h_1 \cap h_2 \cap \dots \cap h_i\)</span>. הרעיון הוא שבכל שלב מצמצמים את התחום הפיזיבילי, ויש שתי אפשרויות עבור <span class="math inline">\(v_i\)</span>:</p>
<p>אם <span class="math inline">\(v_{i-1}\in h_i\)</span> (כמו באיור הימני למטה), אז <span class="math inline">\(h_i\)</span> לא שינה את הפתרון האופטימלי ולכן <span class="math inline">\(v_i = v_{i-1}\)</span>. אחרת, <span class="math inline">\(h_i\)</span> גרם לכך ש-<span class="math inline">\(C_i\)</span> כבר לא כולל את <span class="math inline">\(v_{i-1}\)</span> (כמו באיור השמאלי למטה). בספר תראו הוכחה לכך שבמקרה זה, אם <span class="math inline">\(C_i\)</span> לא ריק, אז <span class="math inline">\(v_i\)</span> בהכרח נמצא על הישר <span class="math inline">\(\ell_i\)</span> המגדיר את חצי המישור <span class="math inline">\(h_i\)</span>.</p>
<p align="center" width="100%">
</p>
<p><img src="images/4/incremental_case1.jpg" width="40%"><img src="images/4/incremental_case2.jpg" width="40%"></p>

<p>באופן די מאכזב, זמן הריצה המתקבל מאלגוריתם זה הוא <span class="math inline">\(O(n^2)\)</span>, מכיון שבמקרה השני נצטרך לחשב את החיתוך של <span class="math inline">\(\ell_i\)</span> עם חצאי המישורים <span class="math inline">\(m_1, m_2, h_1, \dots, h_{i-1}\)</span>. לכן, במקרה הגרוע, זמן הריצה עבור השלב ה-<span class="math inline">\(i\)</span> יהיה <span class="math inline">\(O(i)\)</span>.</p>
<div class="rmdwarning">
<p><img src="images/question.png" align="right" width="10%" style="padding:0px 0px 0px 10px"> כמה פעמים יתעדכן הפתרון? נסו לחשוב על המקרה הגרוע ביותר: כמה פעמים לכל היותר יכול לקרות המקרה השני, בו נצטרך לעדכן את <span class="math inline">\(v_i\)</span> בזמן <span class="math inline">\(O(i)\)</span>?</p>
<p>(התשובה נמצאת בפסקה האחרונה של סעיף 4.3 בספר הלימוד)</p>
</div>
<p>בהמשך נראה כיצד בחירה רנדומית של הסדר בו מוסיף האלגוריתם את חצאי המישורים, מובילה לתוחלת זמן ריצה לינארית.</p>
<div id="קראו-את-חלקו-השני-של-סעיף-4.3-בספר-הלימוד-עמודים-7376." class="section level4 unnumbered">
<h4>קראו את חלקו השני של סעיף 4.3 בספר הלימוד (עמודים 73–76).<a class="anchor" aria-label="anchor" href="#%D7%A7%D7%A8%D7%90%D7%95-%D7%90%D7%AA-%D7%97%D7%9C%D7%A7%D7%95-%D7%94%D7%A9%D7%A0%D7%99-%D7%A9%D7%9C-%D7%A1%D7%A2%D7%99%D7%A3-4.3-%D7%91%D7%A1%D7%A4%D7%A8-%D7%94%D7%9C%D7%99%D7%9E%D7%95%D7%93-%D7%A2%D7%9E%D7%95%D7%93%D7%99%D7%9D-7376."><i class="fas fa-link"></i></a>
</h4>
</div>
</div>
<div id="rand-alg" class="section level3" number="4.3.3">
<h3>
<span class="header-section-number">4.3.3</span> אלגוריתם רנדומי<a class="anchor" aria-label="anchor" href="#rand-alg"><i class="fas fa-link"></i></a>
</h3>
<p>כמו שהובטח בחלקים הקודמים, תכנון לינארי במישור אכן ניתן לפיתרון בזמן צפוי של <span class="math inline">\(O( n )\)</span>, על ידי האלגוריתם
2DRandomizedBoundedLP אותו נציג בחלק זה. זהו כמובן אלגוריתם רנדומי, והוא זהה כמעט לחלוטין לאלגוריתם האינקרמטלי שהוצג בסעיף הקודם: ההבדל היחידי הוא בשורה השנייה של האלגוריתם, שם מחשבים פרמוטציה אקראית של חצאי המישורים בעזרת פרוצדורה בשם RandomPermutation.</p>
<p>בסרטון הבא נראה כיצד שינוי זה, שנראה לכאורה כאילו אינו משפיע על האלגוריתם, מוביל לתופעה מעניינת ביותר: תוחלת זמן ריצה תהיה לינארית. כלומר, כאשר מגרילים את הסדר בו האלגוריתם האינקמנטלי בוחן את חצאי המישורים, מקבלים שבממוצע על פני כל הפרמוטציות האפשריות, זמן הריצה הוא <span class="math inline">\(O( n )\)</span>.</p>
<div id="צפו-בסרטון-הבא-4" class="section level4 unnumbered">
<h4>צפו בסרטון הבא:<a class="anchor" aria-label="anchor" href="#%D7%A6%D7%A4%D7%95-%D7%91%D7%A1%D7%A8%D7%98%D7%95%D7%9F-%D7%94%D7%91%D7%90-4"><i class="fas fa-link"></i></a>
</h4>
<iframe width="560" height="315" src="https://www.youtube.com/embed/f8OanQaN_D0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
</div>
<div id="קראו-את-סעיף-4.3-בספר-הלימוד-עמודים-6668." class="section level4 unnumbered">
<h4>קראו את סעיף 4.3 בספר הלימוד (עמודים 66–68).<a class="anchor" aria-label="anchor" href="#%D7%A7%D7%A8%D7%90%D7%95-%D7%90%D7%AA-%D7%A1%D7%A2%D7%99%D7%A3-4.3-%D7%91%D7%A1%D7%A4%D7%A8-%D7%94%D7%9C%D7%99%D7%9E%D7%95%D7%93-%D7%A2%D7%9E%D7%95%D7%93%D7%99%D7%9D-6668."><i class="fas fa-link"></i></a>
</h4>
</div>
</div>
<div id="unbounded-LP" class="section level3" number="4.3.4">
<h3>
<span class="header-section-number">4.3.4</span> תוכנית לינארית שאינה חסומה<a class="anchor" aria-label="anchor" href="#unbounded-LP"><i class="fas fa-link"></i></a>
</h3>
<p>בסעיפים הקודמים נמנענו מהטיפול במקרה בו התוכנית הלינארית אינה חסומה, על ידי הוספת שני אילוצים מלאכותיים, <span class="math inline">\(m_1,m_2\)</span>. בחלק זה נראה כיצד ניתן לבדוק האם תוכנית לינארית היא חסומה, ואם היא לא חסומה, נראה כיצד למצוא שני אילוצים <span class="math inline">\(h_1,h_2\)</span> שישמשו אותנו לאתחול האלגוריתם במקום <span class="math inline">\(m_1,m_2\)</span>.</p>
<p>אם התוכנית הלינארית אינה חסומה, אז קיימת קרן <span class="math inline">\(\rho\)</span> המוכלת כולה באיזור הפיזיבילי <span class="math inline">\(C\)</span>. הקרן הזו מוגדרת על ידי נקודה p וכיוון <span class="math inline">\(\overrightarrow{d}\)</span>. נשים לב שפונקציית המטרה מקבלת ערכים הולכים וגדלים לאורך הקרן rho אם ורק אם הזווית הקטנה בין הוקטור <span class="math inline">\(\overrightarrow{d}\)</span> לוקטור המטרה <span class="math inline">\(\overrightarrow{c}\)</span> קטנה מ-<span class="math inline">\(90 ^\circ\)</span>. בנוסף, לכל חצי מישור <span class="math inline">\(h\)</span>, הזוית בין <span class="math inline">\(\overrightarrow{d}\)</span> לנורמל <span class="math inline">\(\overrightarrow{\mu}( h )\)</span> של h (בכיוון הצד הפיזיבילי) היא לכל היותר . ניתן לראות דוגמה לכך בציור מטה. נוסף לכך, אוסף האילוצים עבורם <span class="math inline">\(\overrightarrow{\mu}( h )\)</span> בדיוק מאונך ל-<span class="math inline">\(\overrightarrow{d}\)</span> (<span class="math inline">\(h_1, h_5\)</span> באיור), חייב להיות פיזיבילי.</p>
<p align="center" width="100%">
</p>
<div class="inline-figure"><img src="images/4/unboundedLP.jpg" width="40%"></div>

<p>שימו לב שהבעיה של מציאת הקרן <span class="math inline">\(\rho\)</span> דומה לבעיית הייצור באמצעות תבניות שראינו בחלק הראשון של יחידה זו. מכיוון שכאן הבעיה מוגדרת בשני מימדים, נוכל לפתור אותה על ידי תכנון לינארי במימד אחד, בזמן <span class="math inline">\(O( n )\)</span>. בסעיף 4.5 של ספר תוכלו לקרוא תיאור מפורט של פתרון זה.</p>
<div id="קראו-את-סעיף-4.4-בספר-הלימוד-עמודים-7982." class="section level4 unnumbered">
<h4>קראו את סעיף 4.4 בספר הלימוד (עמודים 79–82).<a class="anchor" aria-label="anchor" href="#%D7%A7%D7%A8%D7%90%D7%95-%D7%90%D7%AA-%D7%A1%D7%A2%D7%99%D7%A3-4.4-%D7%91%D7%A1%D7%A4%D7%A8-%D7%94%D7%9C%D7%99%D7%9E%D7%95%D7%93-%D7%A2%D7%9E%D7%95%D7%93%D7%99%D7%9D-7982."><i class="fas fa-link"></i></a>
</h4>
<div class="rmdnote">
<p><strong>פתרון אלטרנטיבי</strong>:</p>
<p><img src="images/4/unbounded-alg-1.jpg" align="left" width="33%"> דרך אחרת למציאת הקרן <span class="math inline">\(\rho\)</span>, היא להתבונן בחצי המישור <span class="math inline">\(h_i\)</span> עבורו הזווית הקטנה בין <span class="math inline">\(\overrightarrow{c}\)</span> ל-<span class="math inline">\(\overrightarrow{\mu}( h_i )\)</span> היא הגדולה ביותר.</p>
<p> <br>
 </p>
<p><img src="images/4/unbounded-alg-2.jpg" align="left" width="33%"> החיתוך בין הישר לבין חצי מישור אחר <span class="math inline">\(h_j\)</span> הוא קרן <span class="math inline">\(\rho\)</span> על . אם לכל <span class="math inline">\(j \neq i\)</span> הזוית הקטנה בין הקרן <span class="math inline">\(\rho\)</span> שמוגדרת על ידי <span class="math inline">\(\ell_1 \cap h_j\)</span> לבין <span class="math inline">\(\overrightarrow{c}\)</span> קטנה או שווה ל-, אז הקרן שראשיתה בנקודה הקיצונית ביותר בכיוון <span class="math inline">\(\overrightarrow{c}\)</span> היא העדות לכך ש-C אינו חסום ביחס ל-<span class="math inline">\(\overrightarrow{c}\)</span>.</p>
<p><img src="images/4/unbounded-alg-3.jpg" align="left" width="33%"> אחרת, אם עבור <span class="math inline">\(h_j\)</span> כלשהו הזוית הקטנה בין <span class="math inline">\(\rho\)</span> ל-<span class="math inline">\(\overrightarrow{c}\)</span> גדולה מ-, אז חצאי המישורים <span class="math inline">\(h_i\)</span> ו-<span class="math inline">\(h_j\)</span> הם ההוכחה לכך ש-<span class="math inline">\(C\)</span> חסום ביחס ל-<span class="math inline">\(\overrightarrow{c}\)</span>. הסיבה לכך היא שהזווית בין <span class="math inline">\(\overrightarrow{c}\)</span> ל-<span class="math inline">\(\overrightarrow{\mu}( h_j )\)</span> קטנה יותר מהזווית בין <span class="math inline">\(\overrightarrow{c}\)</span> ל-<span class="math inline">\(\overrightarrow{\mu}( h_i )\)</span>, ולכן הזוית בין <span class="math inline">\(h_j\)</span> ל-<span class="math inline">\(\overrightarrow{c}\)</span> גדולה מ-<span class="math inline">\(90^\circ\)</span>.
 </p>
</div>

</div>
</div>
</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="pol-tringle.html"><span class="header-section-number">3</span> שילושי פוליגונים ובעיית הגלריה לאמנות</a></div>
<div class="next"><a href="orthogonal-range-seach.html"><span class="header-section-number">5</span> חיפוש בתחומים אורתוגונלים</a></div>
</div></main><div class="col-md-3 col-lg-3 d-none d-md-block sidebar sidebar-chapter border-right">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>ביחידה זו:</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#linear-prog"><span class="header-section-number">4</span> תכנון ליניארי וחיתוך של חצאי מישורים</a></li>
<li>
<a class="nav-link" href="#preface"><span class="header-section-number">4.1</span> הקדמה</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#molding-prob"><span class="header-section-number">4.1.1</span> בעיית הייצור באמצעות תבניות</a></li>
<li><a class="nav-link" href="#geom-model"><span class="header-section-number">4.1.2</span> מודל גאומטרי לבעיה</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#line-int"><span class="header-section-number">4.2</span> חיתוך של חצאי מישורים</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#div-con-alg"><span class="header-section-number">4.2.1</span> אלגוריתם בשיטת הפרד ומשול</a></li>
<li><a class="nav-link" href="#convex-int"><span class="header-section-number">4.2.2</span> חיתוך של פוליגונים קמורים</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#planar-LP"><span class="header-section-number">4.3</span> תכנון לינארי במישור</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#what-is-LP"><span class="header-section-number">4.3.1</span> מהו תכנון לינארי?</a></li>
<li><a class="nav-link" href="#inc-alg"><span class="header-section-number">4.3.2</span> אלגוריתם אינקרמנטלי</a></li>
<li><a class="nav-link" href="#rand-alg"><span class="header-section-number">4.3.3</span> אלגוריתם רנדומי</a></li>
<li><a class="nav-link" href="#unbounded-LP"><span class="header-section-number">4.3.4</span> תוכנית לינארית שאינה חסומה</a></li>
</ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p dir="rtl" style="text-align:right;">הספר "<strong>גאומטריה חישובית</strong>" נכתב על ידי ד’’ר עומרית פילצר. עדכון אחרון: 2023-09-04.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
