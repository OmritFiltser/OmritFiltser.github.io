% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\usepackage{soul}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\usepackage{float}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{apalike}
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={גאומטריה חישובית},
  pdfauthor={ד'\,'ר עומרית פילצר},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{גאומטריה חישובית}
\author{ד'\,'ר עומרית פילצר}
\date{2023-08-24}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{before-we-start}{%
\chapter*{ברוכים הבאים}\label{before-we-start}}
\addcontentsline{toc}{chapter}{ברוכים הבאים}

ספר זה נועד ללוות את הלומדים בקורס גאומטריה חישובית לתואר ראשון, המבוסס על הספר Computational Geometry: Algorithms and Applications מאת
Mark de Berg, Otfried Cheong, Marc van Kreveld, Mark Overmars.

\hypertarget{welcome}{%
\section*{לפני שמתחילים}\label{welcome}}
\addcontentsline{toc}{section}{לפני שמתחילים}

לפני שנתחיל, הנה מספר פרטים שכדאי לדעת:

\begin{itemize}
\item
  \textbf{למי מיועד הקורס?} תלמידים בשלב מתקדם בתואר הראשון, וכן תלמידי תואר שני, במתימטיקה ומדעי המחשב. הקורס מתאים למי שמעוניין להתנסות בתחום מחקר תיאורטי, וגם למי שמחפש בסיס תיאורטי לישומים מעשיים.
\item
  \textbf{למה לי בכלל ללמוד גאומטריה חישובית?}~לאלגוריתמים ומבני הנתונים שנלמד יש אינספור יישומים מעשיים חשובים במגוון של תחומים רלוונטיים, כמו גרפיקה וראייה מומחשבת, מערכות מידע גאוגרפיות, ניתוח מידע רב, ועוד. תוכלו לרכוש לעצמכם אוסף של כלים, מודלים, וטכניקות, המוכנים לשליפה ומימוש במגוון של בעיות אלגוריתמיות. נוסף על כך, יש בהם גם יופי מרתק, שנמצא בתכונות הגיאומטריות, בהגדרה הנקיה של הבעיות, ובאופי האסתטי של הפתרונות. בקורס הזה נלמד בעיקר את הטכניקות והאלגוריתמים המהווים בסיס רעיוני למימושים נפוצים, אך גם נושאים הנמצאים בחזית המחקר היום.
\end{itemize}

\hypertarget{ux5d0ux5d5ux5e4ux5df-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5d1ux5e7ux5d5ux5e8ux5e1}{%
\subsubsection*{אופן הלימוד בקורס}\label{ux5d0ux5d5ux5e4ux5df-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5d1ux5e7ux5d5ux5e8ux5e1}}
\addcontentsline{toc}{subsubsection}{אופן הלימוד בקורס}

\begin{itemize}
\item
  \textbf{מבנה הקורס:}~בקורס 12 יחידות, כל יחידה תתחיל בהצגה של בעיה חדשה (או אוסף חדש של בעיות), ולאחר מכן יוצגו הכלים (מבני נתונים, אלגוריתמים, מודלים) המתאימים לפתרון.
\item
  \textbf{ספרי הלימוד:} הספר המרכזי של הקורס, אשר~ישמש אותנו ביחידות 1-10, הוא~\\
  \href{http://www.cs.uu.nl/geobook/}{\textbf{Computational Geometry: Algorithms and Applications}}.\\
  שני הפרקים האחרונים בקורס יבוססו על שני פרקים בספר\\
  \href{https://sarielhp.org/book/}{\textbf{Geometric Approximation Algorithms}}.
\item
  \textbf{ידע קודם:}~בקורס נדרש ידע בנושאים של סיבוכיות אסימפטוטית, אלגוריתמים ומבני נתונים בסיסיים.
\item
  \textbf{שאלות עזר מנחות:}~במהלך כל אחת מיחידות הלימוד יופיעו שאלות הבנה פשוטות (ללא ציון), שיעזרו לכם לוודא שהבנתם באופן בסיסי את ההגדרות והרעיונות של הפרק.
\item
  \textbf{יש נושא ספיציפי שמעניין אתכם? רוצים לראות דוגמאות נוספות?} חומרי עזר לקריאה נוספת והעשרה ינתנו במקומות הרלוונטים.~
\item
  \textbf{מצאתם טעות בחומר הלימוד?} אם מצאתם טעות או בעיה בחומר הלימוד -- בין אם זו שגיאת כתיב, טעות בנוסחה, או חור בהוכחה - אנא כתבו לי.
\end{itemize}

\hypertarget{intro}{%
\chapter{מבוא}\label{intro}}

\hypertarget{preface}{%
\section{הקדמה}\label{preface}}

\hypertarget{what-is-cg}{%
\subsection{מהי גאומטריה חישובית?}\label{what-is-cg}}

גאומטריה חישובית היא תחום מחקר במדעי המחשב העוסק בפיתוח של כלים, מודלים, מבני נתונים, ואלגוריתמים, המיועדים לפתרון בעיות חישוב גאומטריות. המחקר התיאורטי בגאומטריה חישובית מיושם בתחומים רבים ומגוונים. בסרטון הבא נספר איך נולד התחום, ונציג מספר דוגמאות לבעיות שבהן נעסוק במהלך הקורס.

\hypertarget{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0.}{%
\subsubsection*{צפו בסרטון הבא.}\label{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0.}}
\addcontentsline{toc}{subsubsection}{צפו בסרטון הבא.}

\hypertarget{ux5deux5d3ux5d3ux5d9ux5dd-ux5dcux5d4ux5e2ux5e8ux5dbux5ea-ux5d8ux5d9ux5d1-ux5d4ux5e4ux5eaux5e8ux5d5ux5df.}{%
\subsubsection*{מדדים להערכת טיב הפתרון.}\label{ux5deux5d3ux5d3ux5d9ux5dd-ux5dcux5d4ux5e2ux5e8ux5dbux5ea-ux5d8ux5d9ux5d1-ux5d4ux5e4ux5eaux5e8ux5d5ux5df.}}
\addcontentsline{toc}{subsubsection}{מדדים להערכת טיב הפתרון.}

פתרון לבעיה יכול להיות בצורה של אלגוריתם, המקבל קלט ומייצר פלט מתאים. במקרה זה טיב הפתרון נמדד ב\textbf{זמן הריצה} של האלגוריתם, וב\textbf{סיבוכיות הזיכרון} הנדרשת לפעולתו.

כאשר הפתרון הוא בצורה של מבנה נתונים, קיים מדד נוסף, שהוא זמן העיבוד המקדים. לכן, בניתוח של מבנה נתונים נתייחס לכל אחד מהמדדים הבאים:

\begin{itemize}
\item
  \textbf{זמן עיבוד מקדים (Preprocessing Time)} - הזמן שלוקח לנו לעבד את הקלט ולבנות את מבנה הנתונים.
\item
  \textbf{סיבוכיות מקום/זיכרון (Storage Space)} - גודל הזיכרון או נפח האחסון לו נזדקק עבור מבנה הנתונים.
\item
  \textbf{זמן שאילתה (Query Time)} - זמן הריצה של אלגוריתם השאילתה.
\end{itemize}

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d4ux5d4ux5e7ux5d3ux5deux5d4-ux5dcux5e4ux5e8ux5e7-1-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-12.}{%
\subsubsection*{קראו את ההקדמה לפרק 1 בספר הלימוד (עמודים 1--2).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d4ux5d4ux5e7ux5d3ux5deux5d4-ux5dcux5e4ux5e8ux5e7-1-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-12.}}
\addcontentsline{toc}{subsubsection}{קראו את ההקדמה לפרק 1 בספר הלימוד (עמודים 1--2).}

\hypertarget{ux5eaux5d7ux5d5ux5deux5d9-ux5d9ux5d9ux5e9ux5d5ux5dd.}{%
\subsubsection*{תחומי יישום.}\label{ux5eaux5d7ux5d5ux5deux5d9-ux5d9ux5d9ux5e9ux5d5ux5dd.}}
\addcontentsline{toc}{subsubsection}{תחומי יישום.}

להרחבה על האפליקציות השונות והתפקיד שמשחקת בהן הגאומטריה החישובית, מומלץ לקרוא את פרק 1.3 בספר.

\hypertarget{basic-prop}{%
\subsection{מאפיינים חשובים}\label{basic-prop}}

כמו בכל תחום מדעי, למחקר בגאומטריה חישובית יש מספר מאפיינים שהתקבעו כתוצאה מתחומי העניין והמומחיות של החוקרים בתחום. כאן נתאר את העיקריים שבהם.

\hypertarget{ux5e8ux5d9ux5d2ux5d5ux5e8ux5d5ux5d6ux5d9ux5d5ux5ea.}{%
\subsubsection*{ריגורוזיות.}\label{ux5e8ux5d9ux5d2ux5d5ux5e8ux5d5ux5d6ux5d9ux5d5ux5ea.}}
\addcontentsline{toc}{subsubsection}{ריגורוזיות.}

לפני שהתפתח המחקר בגאומטריה חישובית, היו המון היוריסטיקות ופתרונות אד הוק ליישומים גאומטרים. פתרונות כאלה נבדקו על ידי ביצוע ניסויים, ולכן היו בדרך כלל יעילים רק במצבים מסוימים, ולעיתים אף שגויים לחלוטין. לעומת זאת, תחום הגאומטריה החישובית התפתח כתחום מתמטי שבו הגישה לפתרון היא ריגורוזית: הבעיות מוגדרות היטב, וכל פתרון כולל הוכחת יעילות ונכונות מתמטית.

\hypertarget{ux5deux5d9ux5deux5d3-ux5e0ux5deux5d5ux5da.}{%
\subsubsection*{מימד נמוך.}\label{ux5deux5d9ux5deux5d3-ux5e0ux5deux5d5ux5da.}}
\addcontentsline{toc}{subsubsection}{מימד נמוך.}

היסטורית, הגאומטריה החישובית התפתחה כתחום מחקר העוסק בבעיות על מרחבים ממימד אוקלידי נמוך (לרוב מרחב דו-מימדי, ולעיתים גם תלת מימדי). לכן לאורך הקורס אנו נתמקד בעיקר במרחב אוקלידי הדו-מימדי, \(\mathbb{R}^2\) , שמכונה גם \textbf{המישור האוקלידי} (או בקיצור, המישור). רוב האלגוריתמים שנראה יעבדו רק בשניים או שלושה מימדים. אלגוריתמים שמתאימים גם למימדים גבוהים יותר סובלים במקרים רבים מתופעה שנקראת \textbf{``קללת המימד הגבוה''} (curse of high dimensionality), כלומר, זמן הריצה שלהם כולל פקטורים שגדלים אקספוננצילית במימד. עם זאת, לעיתים נדון גם באפשרות להרחבה למימדים גבוהים יותר, או בהבדלים הקיימים במעבר למימד גבוה יותר.

\hypertarget{ux5e7ux5dcux5d8-ux5d1ux5d3ux5d9ux5d3-ux5d3ux5d9ux5e1ux5e7ux5e8ux5d8ux5d9.}{%
\subsubsection*{קלט בדיד (דיסקרטי).}\label{ux5e7ux5dcux5d8-ux5d1ux5d3ux5d9ux5d3-ux5d3ux5d9ux5e1ux5e7ux5e8ux5d8ux5d9.}}
\addcontentsline{toc}{subsubsection}{קלט בדיד (דיסקרטי).}

תחום הגאומטריה החישובית מתמקד בבעיות בהן האובייקטים הנתונים הם \textbf{בדידים} בטבעם, למשל קבוצות סופיות של נקודות, ישרים, או מעגלים. קיימות אפליקציות רבות בהן האובייקטים הם \textbf{רציפים}, כמו למשל מרחב תלת מימדי המתאר את טמפרטורת האוויר באיזור מסוים. מכיוון שהחישוב בעזרת מחשב הוא \textbf{בדיד} בטבעו, במקרים כאלו נדרש תהליך של \textbf{דיסקרטיזציה}, המאפשר לקבל קירוב לפתרון הרציף. בקורס הזה נדבר על בעיות עם קלט בדיד, ולא נדון בתהליך הדיסקרטיזציה.

\hypertarget{ux5d4ux5deux5d5ux5d3ux5dc-ux5d4ux5d7ux5d9ux5e9ux5d5ux5d1ux5d9.}{%
\subsubsection*{המודל החישובי.}\label{ux5d4ux5deux5d5ux5d3ux5dc-ux5d4ux5d7ux5d9ux5e9ux5d5ux5d1ux5d9.}}
\addcontentsline{toc}{subsubsection}{המודל החישובי.}

לפני שניגשים לניתוח יעילות של אלגוריתם, צריך להחליט באיזה מודל חישובי הוא פועל. המודל החישובי מגדיר את הקשר בין הקלט ופעולות האלגוריתם לבין ייצוגם ואופן חישובם במחשב. בתחום הגאומטריה החישובית מקובל להשתמש במודל מתמטי הנקרא \textbf{מודל RAM הממשי (real RAM)}. זהו מודל המבוסס על המודל המוכר של Random Access Machine, כלומר הגישה לתאי הזיכרון היא באמצעות מצביעים. אלגוריתמים לבעיות גאומטריות דורשים בדרך כלל חישובים על מספרים ממשיים, וכאשר מתרגמים אלגוריתמים אלו לתוכניות מחשב, המספרים המחושבים הם בעצם מקורבים, כתלות בדיוק המחשב. מודל זה מאפשר להזניח את בעיית שגיאות העיגול בייצוג המקורב של הממשיים: כל מספר ממשי ניתן לאחסון ביחידת זיכרון אחת, והמספרים הם מדויקים ולא מקורבים. כמו כן המודל מניח שהפעולות האריתמטיות (חיבור, חיסור, כפל, וחילוק), וכן פעולות השוואה, מתבצעות בזמן קבוע על מספרים ממשיים.

על אף כוחו הבלתי רגיל של מודל RAM הממשי, קיימות מספר שפות תכנות המיועדות למימוש אלגוריתמים גאומטריים ומאפשרות סימולציה שלו. הרעיון בסימולציה כזו הוא שרמת הדיוק בחישוב וייצוג המספרים משתנה בהתאם לצרכי האלגוריתם, כך שניתן יהיה לבצע השוואות מדויקות ולהימנע מטעויות עיגול. לדוגמה, \href{https://www.cgal.org/}{\textbf{הספריה CGAL}} תומכת בחישובים גאומטריים מדוייקים באמצעות מנגנון מסוג זה.

\hypertarget{more-tools}{%
\section{כלים ומקורות נוספים}\label{more-tools}}

בסעיף זה ירוכזו כלים שימושיים לקורס, ומקורות נוספים ללמידה והעשרה.

\hypertarget{ux5dbux5dcux5d9ux5dd-ux5deux5d5ux5deux5dcux5e6ux5d9ux5dd-ux5dcux5e9ux5d9ux5deux5d5ux5e9-ux5d1ux5e7ux5d5ux5e8ux5e1.}{%
\subsubsection*{כלים מומלצים לשימוש בקורס.}\label{ux5dbux5dcux5d9ux5dd-ux5deux5d5ux5deux5dcux5e6ux5d9ux5dd-ux5dcux5e9ux5d9ux5deux5d5ux5e9-ux5d1ux5e7ux5d5ux5e8ux5e1.}}
\addcontentsline{toc}{subsubsection}{כלים מומלצים לשימוש בקורס.}

\begin{itemize}
\tightlist
\item
  \href{https://ipe.otfried.org/}{\textbf{Ipe}}- כלי חינמי מצוין לציורים גאומטריים שפותח ע''י Otfried Cheong, חוקר בגאומטריה חישובית. מדריך מצוין לכלי זה ניתן למצוא \href{https://www.youtube.com/watch?v=moM4CATxTgw\&ab_channel=V\%C3\%A1clavBla\%C5\%BEej}{\textbf{כאן}}.
\item
  \href{https://www.geogebra.org/geometry}{\textbf{Geogebra}}- כלי ליצירת אובייקטים גאומטריים אינטראקטיביים.
\item
  \href{https://www.cgal.org/}{\textbf{CGAL}} - ספריית C++ המכילה מגוון של אלגוריתמים ומבני נתונים גאומטריים.
\end{itemize}

\hypertarget{ux5d4ux5e8ux5e6ux5d0ux5d5ux5ea-ux5deux5d5ux5e7ux5dcux5d8ux5d5ux5ea-ux5d5ux5d7ux5d5ux5deux5e8ux5d9-ux5dcux5d9ux5deux5d5ux5d3-ux5e0ux5d5ux5e1ux5e4ux5d9ux5dd}{%
\subsubsection*{הרצאות מוקלטות וחומרי לימוד נוספים}\label{ux5d4ux5e8ux5e6ux5d0ux5d5ux5ea-ux5deux5d5ux5e7ux5dcux5d8ux5d5ux5ea-ux5d5ux5d7ux5d5ux5deux5e8ux5d9-ux5dcux5d9ux5deux5d5ux5d3-ux5e0ux5d5ux5e1ux5e4ux5d9ux5dd}}
\addcontentsline{toc}{subsubsection}{הרצאות מוקלטות וחומרי לימוד נוספים}

למעוניינים בכך, ניתן למצוא חומרי לימוד מצויינים מקורסים דומים הניתנים ברחבי העולם. הנה רשימה חלקית ביותר של הבולטים שבהם:

\begin{itemize}
\tightlist
\item
  \href{http://www.cs.umd.edu/class/spring2020/cmsc754/Lects/cmsc754-spring2020-lects.pdf}{\textbf{CMSC 754 Computational Geometry}}, by David M. Mount.
\item
  \href{https://geometry.inf.ethz.ch/gca18.pdf}{\textbf{Geometry: Combinatorics and Algorithms}}, by Luis Barba Bernd Gärtner, Michael Hoffmann and Emo Welzl.
\item
  \href{https://www.youtube.com/@PhilippKindermann/playlists?view=50\&sort=dd\&shelf_id=2}{\textbf{Computational Geometry}}, video lectures by Philipp Kindermann.
\end{itemize}

\hypertarget{notations}{%
\section{מושגי יסוד}\label{notations}}

\hypertarget{basic-objects}{%
\subsection{אובייקטים גאומטריים בסיסיים}\label{basic-objects}}

בחלק זה מופיעה רשימה של הגדרות בסיסיות איתן נעבוד. גם אם אתם כבר מכירים את כולן או את רובן, מומלץ בכל זאת לקרוא את הפרק כדי לודא שאתם מבינים את הניסוח המתמטי שבו נשתמש בקורס. תוכלו לחזור לפרק זה בכל עת, אם תרצו להיזכר באחת מההגדרות.

\hypertarget{ux5deux5e8ux5d7ux5d1-ux5d0ux5d5ux5e7ux5dcux5d9ux5d3ux5d9-ux5e0ux5e7ux5d5ux5d3ux5d4-ux5e0ux5d5ux5e8ux5deux5d4-ux5d5ux5deux5e8ux5d7ux5e7}{%
\subsubsection*{מרחב אוקלידי, נקודה, נורמה ומרחק}\label{ux5deux5e8ux5d7ux5d1-ux5d0ux5d5ux5e7ux5dcux5d9ux5d3ux5d9-ux5e0ux5e7ux5d5ux5d3ux5d4-ux5e0ux5d5ux5e8ux5deux5d4-ux5d5ux5deux5e8ux5d7ux5e7}}
\addcontentsline{toc}{subsubsection}{מרחב אוקלידי, נקודה, נורמה ומרחק}

\hypertarget{curves-polygons}{%
\subsection{עקומים ופוליגונים}\label{curves-polygons}}

\hypertarget{special-polygons}{%
\subsection{פוליגונים מיוחדים}\label{special-polygons}}

\hypertarget{convex-hull}{%
\section{הקמור של קבוצת נקודות במישור}\label{convex-hull}}

\hypertarget{convex-hull-def}{%
\subsection{הגדרת הקמור}\label{convex-hull-def}}

הדוגמה הראשונה לבעיה גאומטרית שנלמד בקורס היא בעיית חישוב הקמור. הקמור של קבוצת נקודות הוא מושג בסיסי וחשוב ביותר, מכיוון שיש לו אינספור שימושים בתחומים שונים ומגוונים. בסרטון הבא נגדיר מהו הקמור של קבוצת נקודות, ונציג דוגמה אחת לשימוש בו - דווקא בבעיה שבמבט ראשון אין לה קשר לגאומטריה, ובהמשך נראה איך בכל זאת הגאומטריה תעזור לנו בפתרון הבעיה.

\hypertarget{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0.-1}{%
\subsubsection*{צפו בסרטון הבא.}\label{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0.-1}}
\addcontentsline{toc}{subsubsection}{צפו בסרטון הבא.}

\textbf{הגדרה}: קבוצה קמורה

קבוצת נקודות \(S\) היא קבוצה קמורה אם לכל זוג נקודות \(p,q\in S\) מתקיים שהקטע \(pq\) מוכל בקבוצה \(S\).

\textbf{הגדרה}: הקמור

עבור קבוצת נקודות \(S\), הקמור (Convex Hull) של S מסומן \(CH(S)\).

לקמור של קבוצת נקודות יש מספר הגדרות שקולות:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  הקמור של קבוצת נקודות \(S\) הוא הקבוצה הקמורה הקטנה ביותר שמכילה את \(S\). (כלומר, לא קיימת קבוצה קמורה שמכילה את \(S\) ומוכלת ממש בקמור של \(S\)).
\item
  הקמור של קבוצת נקודות \(S\) הוא הפוליגון הקמור היחיד שקודקודיו הם נקודות מ-\(S\) ושמכיל את \(S\).
\item
  הקמור של קבוצת נקודות \(S\) הוא החיתוך של כל חצאי המרחבים הסגורים שמכילים את \(S\).
\end{enumerate}

\hypertarget{naive-alg}{%
\subsection{אלגוריתם נאיבי}\label{naive-alg}}

בחלק הראשון של סעיף 1.1 בספר הלימוד מופיעות הגדרות הקמור שראינו קודם, וכן מתואר האלגוריתם \textbf{SlowConvexHull}, שהוא אלגוריתם נאיבי. סיבוכיות זמן הריצה שלו היא \(O(n^3)\), והיא רחוקה מלהיות אופטימלית, אך הוא אינטואיטיבי ונכונותו נובעת ישירות מהאבחנות שעשינו קודם על התכונות הגאומטריות של הקמור.

באלגוריתם זה עולה הנושא של \textbf{מצבים מנוונים} \textbf{(degeneracies)}, אלו הם למעשה מקרי קצה של הקלט שיש לקחת בחשבון. בנוסף, באלגוריתם עולה גם בעיה של \textbf{עמידות החישוב} \textbf{(robustness)}, כלומר במצבים מסוימים של טעויות עיגול בחישובים עם נקודה צפה (floating point), יתכן שהאלגוריתם אפילו לא יחזיר פוליגון. בחלק הרביעי של יחידה זו תוכלו לקרוא עוד על עמידות החישוב ומצבים מנוונים.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e8ux5d0ux5e9ux5d5ux5df-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-1.1-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-25}{%
\subsubsection*{קראו את חלקו הראשון של סעיף 1.1 בספר הלימוד (עמודים 2--5)}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e8ux5d0ux5e9ux5d5ux5df-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-1.1-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-25}}
\addcontentsline{toc}{subsubsection}{קראו את חלקו הראשון של סעיף 1.1 בספר הלימוד (עמודים 2--5)}

\hypertarget{incremental-alg}{%
\subsection{אלגוריתם אינקרמנטלי}\label{incremental-alg}}

בסרטון הבא נתאר את האלגוריתם \textbf{ConvexHull} המופיע בחלקו השני של סעיף 1.1 בספר הלימוד. האלגוריתם הזה נקרא גם \textbf{האלגוריתם האינקרמנטלי}, או \textbf{סריקת גרהם (Graham Scan)}. הוא מתוחכם יותר, וסיבוכיות זמן הריצה שלו היא ~- זמן כמעט לינארי. זהו שיפור משמעותי מאוד לעומת האלגוריתם הנאיבי שראינו בחלק הקודם.~

\hypertarget{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0}{%
\subsubsection*{צפו בסרטון הבא:}\label{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0}}
\addcontentsline{toc}{subsubsection}{צפו בסרטון הבא:}

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e9ux5e0ux5d9-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-1.1-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-68.}{%
\subsubsection*{קראו את חלקו השני של סעיף 1.1 בספר הלימוד (עמודים 6--8).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e9ux5e0ux5d9-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-1.1-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-68.}}
\addcontentsline{toc}{subsubsection}{קראו את חלקו השני של סעיף 1.1 בספר הלימוד (עמודים 6--8).}

\hypertarget{output-sens}{%
\subsection{אלגוריתם רגיש לפלט}\label{output-sens}}

האם ניתן לשפר את זמן הריצה של האלגוריתם האינקרמנטלי שראינו קודם? בסרטון הבא נתאר~ אלגוריתם נוסף לחישוב הקמור, שנקרא \textbf{אלגוריתם עטיפת המתנה (Gift Wrapping)} או \textbf{Jarvis's March}. זמן הריצה שלו הוא, כאשר~~הוא מספר קודקודי הקמור. סוג כזה של אלגוריתם נקרא~\textbf{output~sensitive}, כלומר אלגוריתם שזמן הריצה שלו תלוי בגודל הפלט.

\hypertarget{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0.-2}{%
\subsubsection*{צפו בסרטון הבא.}\label{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0.-2}}
\addcontentsline{toc}{subsubsection}{צפו בסרטון הבא.}

\hypertarget{deg-robust}{%
\section{מצבים מנוונים ועמידות החישוב}\label{deg-robust}}

על מנת לפשט את התיאור של אלגוריתמים גאומטריים, במקרים רבים משתמשים בהנחה שנקראת \textbf{מצב כללי} \textbf{(general position)}. המשמעות היא שהקלט אינו מכיל מצבים \textbf{``מנוונים'' (degenerate)}, למשל, שתי נקודות עם אותה קואורדינטת \(x\), שלוש נקודות על ישר אחד, או ארבע נקודות על מעגל. המטרה היא להימנע מסרבול האלגוריתם כאשר יש צורך בטיפול ב\textbf{מקרי קצה}. לדוגמה, באלגוריתם האינקרמטלי לחישוב הקמור (סריקת גרהם), יש למיין את הנקודות לפי קואורדינטת ה-\(x\) שלהן. אך מה עושים אם יש שתי נקודות בעלות אותה קואורדינטת \(x\)? נצטרך להחליט מי מהן תופיע ראשונה במיון. אמנם כאן נוכל להוסיף תיאור פשוט יחסית, אך יותר קל להניח שהקלט נמצא במצב כללי, כלומר נניח שאין שתי נקודות בעלות אותה קואורדינטת x. הנחות מסוג זה הן מקובלות באלגוריתמים גאומטריים, ומשתנות בהתאם לצרכי האלגוריתם.

מצבים מנוונים קשורים בנושא \textbf{עמידות החישוב} \textbf{(robustness)}, מכיוון שלעיתים הטיפול בהם כרוך בבדיקה הגוררת חישוב שתוצאתו היא אפס. לדוגמה, במימוש אלגוריתם האינקרמנטלי, אנו נדרשים לבדוק האם שלושת הנקודות האחרונות יוצרות פניה ימינה. כלומר, בהינתן שלוש נקודות, \(p_1, p_2, p_3\), נרצה לבדוק האם הזוית שהן יוצרות, כלומר הזוית \(\alpha = \angle p_1 p_2 p_3\), קטנה מ- \(180^\circ\). ניתן לעשות זאת על ידי חישוב של הישר העובר דרך \(p_1 p_2\) ובדיקה האם \(p_3\) נמצאת מעליו או מתחתיו, או על ידי מכפלה וקטורית כפי שנראה בפרק הבא. אם שלושת הנקודות נמצאות על ישר אחד, נקבל שיוויון, כלומר \(\alpha= 180^\circ\). כאשר מבצעים חישוב של מספרים ממשיים במחשב, התוצאה תלויה ברמת הדיוק של המחשב, אשר אינה אינסופית, ולכן בדרך כלל לא נקבל מצב של שיוויון מדויק. לכן, אם שלושת הנקודות נמצאות כמעט על אותו ישר, אי דיוק מזערי בחישוב עלול להביא לתוצאה שגויה, מה שמעלה את השאלה של נכונות האלגוריתם במצבים כגון זה, וזוהי בעצם השאלה של עמידות החישוב.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-1.2-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-810.}{%
\subsubsection*{קראו את סעיף 1.2 בספר (עמודים 8--10).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-1.2-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-810.}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 1.2 בספר (עמודים 8--10).}

\hypertarget{map-overlay}{%
\chapter{מפות מישוריות וטכניקת הישר הסורק}\label{map-overlay}}

\hypertarget{preface}{%
\section{הקדמה}\label{preface}}

\hypertarget{them-map}{%
\subsection{שכבות מידע במפה}\label{them-map}}

ביחידה זו נתייחס לבעיות הנוגעות לחיתוכי קטעים במישור. דוגמה אחת לבעיה
כזו מופיעה בתחום של מערכות מידע גאוגרפיות (GIS - Graphic Information
Systems), כאשר רוצים להציג ולנתח שכבות מידע ממספר מפות. למשל, בהינתן מפה
של נהרות ומפה של כבישים, נוכל להצליב את המידע משתי המפות על מנת למצוא
היכן ממוקמים גשרים: אלו הן נקודות החיתוך בין כבישים לנהרות. כל מפה
נושאית כזו ניתנת לייצוג גאומטרי על ידי אוסף של קטעים, עקומים, או
פוליגונים. בעזרת טכניקות גאומטריות, נוכל למצוא את נקודות החיתוך ולחשב את
הייצוג המאוחד של שתי מפות (map overlay).

תחילה נראה כיצד ניתן למצוא את כל החיתוכים באוסף קטעים נתון, ולשם כך
נשתמש בטכניקה חשובה שימושית מאוד: טכניקת הישר הסורק (sweep-line). לאחר
מכן נדבר על ייצוג של מפות מישוריות (גרפים מישוריים), ונתאר מבנה נתונים
יעיל לאחסונם - DCEL. לבסוף, נראה כיצד ניתן לאחד שני מבנים כאלה, המייצגים
שתי מפות מישוריות, למפה מישורית אחת המאגדת את כל המידע.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d4ux5d4ux5e7ux5d3ux5deux5d4-ux5dcux5e4ux5e8ux5e7-2-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-1920.}{%
\subsubsection*{קראו את ההקדמה לפרק 2 (עמודים 19--20).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d4ux5d4ux5e7ux5d3ux5deux5d4-ux5dcux5e4ux5e8ux5e7-2-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-1920.}}
\addcontentsline{toc}{subsubsection}{קראו את ההקדמה לפרק 2 (עמודים 19--20).}

\hypertarget{sweep-line}{%
\section{טכניקת הישר הסורק}\label{sweep-line}}

\hypertarget{line-int}{%
\subsection{חיתוך קטעים במישור}\label{line-int}}

טכניקת הישר הסורק (sweep-line) היא חשובה ושימושית מאוד בגאומטריה
חישובית. כדי להדגים את השימוש בטכניקה הזו, ולפני שנדבר על מפות מישוריות,
נציג בעיה פשוטה לכאורה שנקראת בעיית חיתוך קטעים במישור (line segment
intersection). בבעיה זו, הקלט הוא אוסף של קטעים במישור, והמטרה היא למצוא
את כל נקודות החיתוך בין קטעים. בסרטון הבא נתאר את רעיון השימוש בישר
הסורק עבור בעיית חיתוך קטעים במישור.

\hypertarget{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-1}{%
\subsubsection*{צפו בסרטון הבא:}\label{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-1}}
\addcontentsline{toc}{subsubsection}{צפו בסרטון הבא:}

בטכניקת הישר הסורק, הרעיון הוא ``לסרוק'' את הקטעים בעזרת ישר אופקי \(\ell\)
הנע מלעלה למטה. ה''\textbf{סטטוס}'' (status) של הישר הוא אוסף הקטעים הנחתכים עם
הישר במיקומו הנוכחי. את הסטטוס יש לעדכן בזמן שהישר נע מטה, אך הוא אינו
מתעדכן באופן רציף - העדכון מתבצע רק כאשר הישר מגיע לנקודות מסויימות, להן
אנו קוראים ``\textbf{מאורעות}'' (event points). בבעיית חיתוך הקטעים, המאורעות
הם נקודות הקצה של הקטעים, וגם נקודות החיתוך עצמן, שמתגלות במהלך
האלגוריתם. בכל פעם שהישר מגיע למאורע, יש לעדכן את הסטטוס ואת תור
המאורעות, ולבצע בדיקות של חיתוכים בין הקטעים בסטטוס.

זמן הריצה של האלגוריתם הראשון שמתואר בסרטון ומשתמש בשיטת הישר הסורק, הוא
\(O(n^2)\). האם קיים אוסף של קטעים ללא נקודות חיתוך כלל, שעבורו זמן הריצה
של האלגוריתם הזה יהיה \(\Theta(n^2)\)?

(פתרון)

באוסף הקטעים שבאיור למטה אין נקודות חיתוך, אך בשלב שבו הקטע ה- \(i\) נוסף
לסטטוס, כבר מופיעים בסטטוס \(i-1\) הקטעים הראשונים, ולכן יהיו \(i-1\)
בדיקות. סך הכל מספר הבדיקות בכל השלבים יהיה \(\Theta(n^2)\).

\hypertarget{line-sweep-impl}{%
\subsection{טכניקת הישר הסורק - מימוש}\label{line-sweep-impl}}

בסעיף הקודם ראינו סקיצה של אלגוריתם המשתמש בטכניקת הישר הסורק, והסברנו
באופן אינטואיטיבי מדוע גישה כזו תתן לנו אלגוריתם יעיל שהוא רגיש לפלט,
ושאינו בודק חיתוכים בין כל זוג קטעים.

כיצד מממשים אלגוריתם כזה ביעילות? בסעיף 2.1 בספר הלימוד מתואר בפירוט
האלגוריתם FindIntersections, מבני הנתונים להם נזדקק עבור תור המאורעות
והסטטוס, והפרוצדורה HandleEvenPoint לטיפול במאורעות. זמן הריצה של
האלגוריתם הוא \(O((n+k)\log n)\), כאשר \(k\) הוא מספר נקודות החיתוך.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d1ux5e2ux5d9ux5d5ux5df-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-2.1-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-2029}{%
\subsubsection*{קראו בעיון את סעיף 2.1 בספר הלימוד (עמודים 20--29)}\label{ux5e7ux5e8ux5d0ux5d5-ux5d1ux5e2ux5d9ux5d5ux5df-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-2.1-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-2029}}
\addcontentsline{toc}{subsubsection}{קראו בעיון את סעיף 2.1 בספר הלימוד (עמודים 20--29)}

\hypertarget{ux5e0ux5d5ux5e1ux5d7ux5ea-ux5d0ux5d5ux5d9ux5dcux5e8}{%
\subsubsection*{נוסחת אוילר}\label{ux5e0ux5d5ux5e1ux5d7ux5ea-ux5d0ux5d5ux5d9ux5dcux5e8}}
\addcontentsline{toc}{subsubsection}{נוסחת אוילר}

בסעיף 2.1 בספר הלימוד, יש שימוש בנוסחת אוילר להשגת חסם על מספר המאורעות.

עבור גרף מישורי עם \(n_v\) קודקודים, \(n_e\) צלעות, ו-\(n_f\) פאות, נוסחת
אוילר מתארת את הקשר ביניהם, באופן הבא.

\textbf{נוסחת אוילר}: \(n_v-n_e+n_f\ge 2\).

זוהי נוסחה חשובה ביותר, ונעשה בה שימוש גם בהמשך הקורס.

נסו לחשוב על אלגוריתם המקבל אוסף של קטעים במישור, ובודק האם קיים זוג
קטעים שנחתכים. איזה זמן ריצה ניתן להשיג?

(פתרון)

שימו לב שניתן להשתמש באותו אלגוריתם שראינו למציאת כל נקודות החיתוך, אך לעצור מייד עם מציאת נקודת החיתוך הראשונה.
נקבל זמן ריצה של \(O(n\log n)\).

\hypertarget{check-line-int}{%
\subsection{כיצד נבדוק האם זוג קטעים נחתכים?}\label{check-line-int}}

במהלך האלגוריתם הסורק שראינו קודם, אנו נדרשים למצוא את נקודת החיתוך בין
שני קטעים נתונים. בהינתן שני קטעים, \(S=\overline{pq}\) ו-
\(S'=\overline{p'q'}\), כיצד נבדוק האם הם נחתכים?

\hypertarget{ux5d2ux5d9ux5e9ux5d4-ux5e8ux5d0ux5e9ux5d5ux5e0ux5d4-ux5d7ux5d9ux5e9ux5d5ux5d1-ux5d4ux5d9ux5e9ux5e8ux5d9ux5dd-ux5d4ux5deux5dbux5d9ux5dcux5d9ux5dd-ux5d0ux5ea-ux5d4ux5e7ux5d8ux5e2ux5d9ux5dd}{%
\subsubsection*{גישה ראשונה: חישוב הישרים המכילים את הקטעים}\label{ux5d2ux5d9ux5e9ux5d4-ux5e8ux5d0ux5e9ux5d5ux5e0ux5d4-ux5d7ux5d9ux5e9ux5d5ux5d1-ux5d4ux5d9ux5e9ux5e8ux5d9ux5dd-ux5d4ux5deux5dbux5d9ux5dcux5d9ux5dd-ux5d0ux5ea-ux5d4ux5e7ux5d8ux5e2ux5d9ux5dd}}
\addcontentsline{toc}{subsubsection}{גישה ראשונה: חישוב הישרים המכילים את הקטעים}

ישר המכיל קטע.נחשב את הישר \(\ell\) המכיל את הקטע \(S\), ואת הישר \(\ell'\)
המכיל את הקטע \(S'\). נחשב את נקודת החיתוך \(t\) בין הישרים \(\ell\)
ו-\(\ell'\). נבדוק האם \(t\) שייכת לשני הקטעים \(S\) ו-\(S'\). בשיטה זו אנו
מוצאים את נקודת החיתוך, אם היא קיימת.

\hypertarget{ux5deux5e6ux5d9ux5d0ux5ea-ux5d4ux5d9ux5e9ux5e8-ux5d4ux5deux5dbux5d9ux5dc-ux5e7ux5d8ux5e2}{%
\subsubsection*{מציאת הישר המכיל קטע:}\label{ux5deux5e6ux5d9ux5d0ux5ea-ux5d4ux5d9ux5e9ux5e8-ux5d4ux5deux5dbux5d9ux5dc-ux5e7ux5d8ux5e2}}
\addcontentsline{toc}{subsubsection}{מציאת הישר המכיל קטע:}

מציבים את שתי נקודות הקצה של הקטע במשוואת הישר \(y=m x + c\), ולאחר מכן
פותרים מערכת של שתי משוואות כדי למצוא את \(m\).

למשל, עבור הקטע \(\overline{pq}\) נסמן \(p=(p_x,p_y)\), \(q=(q_x,q_y)\), ונקבל
\(m=\frac{q_y-p_y}{q_x-p_x}\).

לאחר מכן, מוצאים את \(c\) על ידי הצבה של אחת מהנקודות במשוואה.

שימו לב שאם הקטע \(\overline{p q}\) הוא אנכי, אז המכנה של \(m\) מתאפס.

\hypertarget{ux5deux5e6ux5d9ux5d0ux5ea-ux5e0ux5e7ux5d5ux5d3ux5ea-ux5d4ux5d7ux5d9ux5eaux5d5ux5da-ux5d1ux5d9ux5df-ux5e9ux5e0ux5d9-ux5d9ux5e9ux5e8ux5d9ux5dd}{%
\subsubsection*{מציאת נקודת החיתוך בין שני ישרים:}\label{ux5deux5e6ux5d9ux5d0ux5ea-ux5e0ux5e7ux5d5ux5d3ux5ea-ux5d4ux5d7ux5d9ux5eaux5d5ux5da-ux5d1ux5d9ux5df-ux5e9ux5e0ux5d9-ux5d9ux5e9ux5e8ux5d9ux5dd}}
\addcontentsline{toc}{subsubsection}{מציאת נקודת החיתוך בין שני ישרים:}

בהינתן שני ישרים לא אנכיים,\(\ell: y= m x + c\) ו-\(\ell': y= m'x+ c'\),
נציב את נקודת החיתוך \(t=(t_x,t_y)\) בשתי המשוואות. נפתור ונקבל:
\(t_x=\frac{c-c'}{m'-m}\), \(t_y=\frac{cm'-c'm}{m'-m}\).

גם כאן נשים לב שהמכנה מתאפס אם הישרים אנכיים או מקבילים.

\hypertarget{ux5d1ux5d3ux5d9ux5e7ux5d4-ux5d4ux5d0ux5dd-ux5e0ux5e7ux5d5ux5d3ux5ea-ux5d4ux5d7ux5d9ux5eaux5d5ux5da-ux5e9ux5d9ux5d9ux5dbux5ea-ux5dcux5e7ux5d8ux5e2}{%
\subsubsection*{בדיקה האם נקודת החיתוך שייכת לקטע:}\label{ux5d1ux5d3ux5d9ux5e7ux5d4-ux5d4ux5d0ux5dd-ux5e0ux5e7ux5d5ux5d3ux5ea-ux5d4ux5d7ux5d9ux5eaux5d5ux5da-ux5e9ux5d9ux5d9ux5dbux5ea-ux5dcux5e7ux5d8ux5e2}}
\addcontentsline{toc}{subsubsection}{בדיקה האם נקודת החיתוך שייכת לקטע:}

נניח שמתקיים \(p_x\le q_x\), \(p_y\le q_y\). אז נקודת החיתוך \(t\) שייכת לקטע
\(\overline{p q}\) אם \(t_x\in [p_x, q_y]\), \(t_y\in[p_y, q_y]\).

בשלב השלישי, האם מספיק לבדוק שנקודת החיתוך שייכת לאחד הקטעים?

(פתרון)

בדוגמה המופיעה כאן, הקטעים אינם נחתכים, אך נקודת החיתוך בין הישרים
המכילים אותם מופיעה על אחד הקטעים.

\hypertarget{ux5dbux5d9ux5e6ux5d3-ux5deux5d8ux5e4ux5dcux5d9ux5dd-ux5d1ux5deux5e7ux5e8ux5d9ux5dd-ux5deux5d9ux5d5ux5d7ux5d3ux5d9ux5dd}{%
\subsubsection*{כיצד מטפלים במקרים מיוחדים?}\label{ux5dbux5d9ux5e6ux5d3-ux5deux5d8ux5e4ux5dcux5d9ux5dd-ux5d1ux5deux5e7ux5e8ux5d9ux5dd-ux5deux5d9ux5d5ux5d7ux5d3ux5d9ux5dd}}
\addcontentsline{toc}{subsubsection}{כיצד מטפלים במקרים מיוחדים?}

שימו לב שבגישה הראשונה התעלמנו ממספר מצבים מיוחדים של הקלט, למשל כאשר
הקטעים הם אנכיים. נסו לבדוק בעצמכם מהם מצבי הקלט מהם אנחנו מתעלמים,
וחישבו כיצד ניתן לטפל בהם.

ביחידה הראשונה של הקורס דנו בנושא של מצבים מנוונים. ראינו שניתן לטפל
במצבים מנוונים על ידי חלוקה למקרים נפרדים, אך חלוקה כזו היא בדרך כלל
מתישה ומועדת לטעויות. דרך נוספת לטיפול במצבים כאלו היא למצוא מערכת
גאומטרית אחרת בה המקרים ההמיוחדים נעלמים, למשל על ידי סיבוב מערכת
הצירים, אך פעולה זו לא תמיד אפשרית. אפשרות אחרת היא להשתמש בהנחת מצב
כללי: מניחים שהקלט אינו מכיל מצבים מנוונים.

במקרה של חיתוך ישרים, ניתן למצוא פתרון אחר שבו המקרים המיוחדים אינם
דורשים טיפול נפרד, כמו בגישה הבאה.

\hypertarget{ux5d2ux5d9ux5e9ux5d4-ux5e9ux5e0ux5d9ux5d4-ux5d7ux5d9ux5e9ux5d5ux5d1-ux5d3ux5d8ux5e8ux5deux5d9ux5e0ux5e0ux5d8ux5d4}{%
\subsubsection*{גישה שניה: חישוב דטרמיננטה}\label{ux5d2ux5d9ux5e9ux5d4-ux5e9ux5e0ux5d9ux5d4-ux5d7ux5d9ux5e9ux5d5ux5d1-ux5d3ux5d8ux5e8ux5deux5d9ux5e0ux5e0ux5d8ux5d4}}
\addcontentsline{toc}{subsubsection}{גישה שניה: חישוב דטרמיננטה}

\textbf{אבחנה}:
הקטעים \(S\) ו-\(S'\) חותכים זה את זה אם ורק אם הישר \(\ell\) שמכיל את \(S\)
``מפריד'' בין הנקודות \(p'\) ו-\(q'\) , והישר \(\ell'\) שמכיל את \(S'\) ``מפריד''
בין הנקודות \(p\) ו-\(q\).

\textbf{כיצד נבדוק האם ישר מפריד בין שתי נקודות?} נוכל להמיר את הבעיה הזו
לבעיה הבאה: בהינתן 3 נקודות, \(a,b,c\), נרצה לדעת האם כאשר נעים מ-\(a\)
ל-\(b\) ואחר כך ל-\(c\) מבצעים פניה ימינה, שמאלה, או שממשיכים באותו הכיוון.

לשם כך נחשב את הדטרמיננטה הבאה:
\(det\begin{bmatrix}a_x&a_y&1\\b_x&b_y&1\\c_x&c_y&1\end{bmatrix}=a_xb_y+a_yc_x+b_xc_y-a_yb_x-a_xc_y-b_yc_x\)

הערך המוחלט של הדטרמיננטה הזו שווה בדיוק לפעמיים שטח המשולש
\(\triangle a b c\).

ערכה חיובי אם פונים שמאלה ב-\(b\), שלילי אם פונים ימינה ב-\(b\), ו-0 אם
ממשיכים באותו הכיוון.

לכן, בשיטה זו
נוכל לבדוק האם הנקודות \(p'\) ו-\(q'\) נמצאות בשני צדדים שונים של הישר
\(\ell\) המכיל את \(\overline{pq}\), על ידי חישוב של שתי הדטרמיננטות
המתאימות. לאחר מכן נוכל לבדוק האם הנקודות \(p\) ו-\(q\) נמצאות בשני צדדים
שונים של הישר \(\ell'\) המכיל את \(\overline{p'q'}\).

\hypertarget{dcel}{%
\section{מבנה DCEL}\label{dcel}}

\hypertarget{plan-map}{%
\subsection{יצוג של מפה מישורית}\label{plan-map}}

בחלק
הקודם פתרנו למעשה את בעיית map overlay עבור המקרה הפשוט ביותר, שבו שתי
המפות מיוצגות כאוסף של קטעים. בחלק הזה נדבר על מפות מורכבות יותר, כאלו
שמחלקות את המישור לאיזורים (למשל, מפה המייצגת גידולים חקלאיים שונים). אך
לפני שנוכל לפתור את בעיית map overlay עבור מפות כאלו, נרצה להבין קודם
כיצד בכלל ניתן לייצג ולאחסן מפה כזאת באופן יעיל ונוח לשימוש. זהו בעצם
מבנה הנתונים הגאומטרי הראשון שנראה במהלך הקורס, והוא נקרא DCEL
(Doubly-Connected Edge List).

\hypertarget{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-2}{%
\subsubsection*{צפו בסרטון הבא:}\label{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-2}}
\addcontentsline{toc}{subsubsection}{צפו בסרטון הבא:}

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-2.2-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-2933}{%
\subsubsection*{קראו את סעיף 2.2 בספר (עמודים 29--33)}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-2.2-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-2933}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 2.2 בספר (עמודים 29--33)}

\hypertarget{problem-def}{%
\subsection{בעיית map overlay}\label{problem-def}}

לאחר שראינו כיצד ניתן לייצג מפה מישורית, בחלק זה נראה כיצד ניתן לחשב את
ה-overlay של שתי מפות מישוריות. ה-overlay הוא הייצוג המאוחד של שתי שכבות
מפה כאשר הן מונחות זו על גבי זו.

בהינתן שתי מפות \(\mathcal{S_1}\) ו-\(\mathcal{S_2}\) המיוצגות על ידי מבני
DCEL, נרצה לחשב מבנה DCEL עבור ה-overlay של \(\mathcal{S_1}\) ו-
\(\mathcal{S_1}\), שמסומן \(\mathcal{O}=(\mathcal{S_1},\mathcal{S_2})\).
ה-overlay הוא מפה מישורית, שבה לכל זוג פאות \(f_1\) מ-\(\mathcal{S_1}\)
ו-\(f_2\) מ-\(\mathcal{S_2}\) שהחיתוך שלהן לא ריק, קיימת פאה \(f\) שהיא בדיוק
אחד מרכיבי הקשירות של \(f_1\cap f_2\). (שימו לב ש-\(f_1\) או \(f_2\) יכולות
להיות הפאה החיצונית שאינה חסומה). בנוסף, נרצה לסמן את הפאה \(f\) בסימונים
של הפאות \(f_1\) ו-\(f_2\), כמו בדוגמה הבאה:

בפרק 2.3 של ספר הלימוד מתואר אלגוריתם MapOverlay, המחשב את
\(\mathcal{O}=(\mathcal{S_1},\mathcal{S_2})\) בשיטת הישר הסורק שראינו
קודם.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-2.3-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-3339}{%
\subsubsection*{קראו את סעיף 2.3 בספר (עמודים 33--39)}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-2.3-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-3339}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 2.3 בספר (עמודים 33--39)}

\hypertarget{bool-op}{%
\subsection{פעולות בוליאניות}\label{bool-op}}

אלגוריתם MapOverlay הוא כלי חזק ושימושי במגוון של בעיות. בסעיף 2.4 של
ספר הלימוד מופיעה דוגמה אחת לכך: חישוב של פעולות בוליאניות על שני
פוליגונים. בהינתן שני פוליגונים \(P_1,P_2\), האלגוריתם מאפשר לנו לחשב את
האיחוד, החיתוך, וההפרש שלהם. הרעיון הוא שלאחר חישוב ה-overlay, לכל פאה
בייצוג המאוחד יש תווית שקובעת האם פאה זו שייכת ל-\(P_1\), ל-\(P_2\), או
לשניהם. לכן בעזרת התוויות נוכל להחליט עבור כל פאה האם היא נמצאת באיחוד,
בחיתוך, או בהפרש.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-2.4-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-3940}{%
\subsubsection*{קראו את סעיף 2.4 בספר הלימוד (עמודים 39--40)}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-2.4-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-3940}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 2.4 בספר הלימוד (עמודים 39--40)}

\hypertarget{pol-tringle}{%
\chapter{שילושי פוליגונים ובעיית הגלריה לאמנות}\label{pol-tringle}}

\hypertarget{preface}{%
\section{הקדמה}\label{preface}}

\hypertarget{agp}{%
\subsection{בעיית הגלריה לאמנות}\label{agp}}

גלריות ומוזיאונים משקיעים מאמצים רבים בשמירה על אוצרותיהם, למשל, הצבת שומרים או מצלמות שיוכלו לראות כל פינה בגלריה. במהלך היום, שומרים המסתובבים בגלריה יכולים למנוע גניבה, אולם בלילה מלאכה זו בדרך-כלל נעשית על ידי מצלמות או חיישנים. יכולות להיות מספר סיבות לדרוש מספר קטן ככל האפשר של מצלמות כאלה; למשל משיקולי עלות, וגם מכיוון שקל יותר לפקח על מספר קטן של מצלמות במקביל. מצד שני, נרצה שהמצלמות יכסו כל פינה בגלריה, ומספר קטן מדי של מצלמות עלול לא להספיק.

אם כן, כמה מצלמות נצטרך להציב על מנת לשמור על כל הגלריה? והיכן נצטרך להציב אותן? בעייה זו היתה ההשראה לאחת הבעיות המפורסמות והמרתקות ביותר בתחום הגיאומטריה החישובית: \textbf{בעיית הגלריה לאמנות}.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d4ux5d4ux5e7ux5d3ux5deux5d4-ux5dcux5e4ux5e8ux5e7-3-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3-45.}{%
\subsubsection*{קראו את ההקדמה לפרק 3 בספר הלימוד (עמוד 45).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d4ux5d4ux5e7ux5d3ux5deux5d4-ux5dcux5e4ux5e8ux5e7-3-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3-45.}}
\addcontentsline{toc}{subsubsection}{קראו את ההקדמה לפרק 3 בספר הלימוד (עמוד 45).}

\hypertarget{geom-model}{%
\subsection{מודל גאומטרי לבעיה}\label{geom-model}}

בעית הגלריה לאמנות נוסחה ב-1973 על-ידי המתמטיקאי ויקטור קלי.

מנקודת מבט גיאומטרית, נוכל לתאר גלריה בעלת \(n\) קירות בעזרת פוליגון פשוט \(P\) בעל \(n\) צלעות (וכמובן גם \(n\) קודקודים), ואת מיקומי המצלמות בתור נקודות בתוך \(P\). נניח שמצלמה יכולה לצלם כל נקודה בגלריה שאינה מוסתרת ממנה על-ידי אחד הקירות. במילים אחרות, מצלמה (נקודה) \(g\) שומרת על נקודה \(p\in P\) אם הקטע \(\overline{pq}\) מוכל בתוך \(P\) (הפנים והשפה של \(P\)).

באיור למטה מתואר פוליגון עם מצלמה יחידה בתוכו, והאיזור המוצלל הוא כל הנקודות שמצלמה זו שומרת עליהן, או ``רואה'' אותן.

מהו המספר המינימלי של מצלמות שנצטרך על מנת לשמור על כל \(P\)? כאן, ברור שהתשובה תלויה במבנה של הפוליגון \(P\).

עבור אילו פוליגונים מספיקה מצלמה יחידה? שימו לב שעבור פוליגון כוכבי מספיקה מצלמה יחידה (לפי הגדרה). גם לכל פוליגון קמור מספיקה מצלמה יחידה. מדוע?

\hypertarget{worst-case}{%
\subsection{מהו המקרה הגרוע ביותר?}\label{worst-case}}

מציאת המספר המינימלי של מצלמות הנדרשות לשמירה על פוליגון נתון \(P\) היא בעיית אופטימיזציה אלגוריתמית, כלומר, הפתרון לה הוא אלגוריתם המחזיר קבוצת נקודות \(G\) מגודל מינימלי, כך שלכל \(p\in P\) קיימת \(g \in G\) כך שהקטע \(\overline{pg}\) מוכל בתוך \(P\) (כלומר \(g\) שומרת על \(p\)). בעיה זו היא NP-קשה, בפרט, לא ידוע האם קיים אלגוריתם כזה עם זמן ריצה פולינומי (ויותר מכך, ההשערה הרווחת היא שלא קיים כזה).

נוכל גם לשאול את השאלה הקומבינטורית הבאה: מהו מספר המצלמות המינימלי הנדרש במקרה הגרוע ביותר? במילים אחרות, היינו רוצים למצוא פונקציה \(g(n)\), כך ש: 1. \(g(n)\) מצלמות מספיקות לכל פוליגון בעל \(n\) קודקודים, וגם 2. קיים פוליגון בעל \(n\) קודקודים שעבורו נדרשות \(g(n)\) מצלמות.

התבוננו במשפחת הפוליגונים הבאה, שלהם צורה דמויית מסרק.

שימו לב שכדי לשמור על פוליגון מסרק עם שתי ``שיניים'' נדרשות שתי מצלמות: המשולשים שהם שיני המסרק אינם נחתכים, ולכן אין נקודה אחת ש''רואה'' את שני הקודקודים העליונים שלהם. עבור מסרק עם 3 שיניים נדרשות 3 מצלמות, וכן הלאה. מהו מספר המצלמות שנצטרך עבור מסרק עם \(k\) שיניים? כמה קודקודים יש למסרק כזה?

ניתן להציג את משפחת פוליגוני המסרק באופן כללי כך: לכל \(n \ge 3\), פוליגון מסרק בעל \(n\) קודקודים מורכב מבסיס שהוא צלע אופקית, ומעליו \(\lfloor n / 3 \rfloor\) שיניים שכל אחת מהן מורכבת משתי צלעות כל אחת, ומחוברות ביניהן על-ידי צלעות אופקיות, כמו באיור הבא:

קל לראות שניתן לבנות את המסרק כך שלא ניתן להציב מצלמה ששומרת על שני קודקודים שנמצאים בקצוות של שיניים שונות. לכן, מספר המצלמות הנדרשות עבור מסרק בעל \(n\) קודקודים הוא \(\lfloor n/3 \rfloor\).

אם כך, ראינו שלכל n קיים פוליגון בעל n קודקודים עבורו מספר המצלמות הנדרש הוא \(\lfloor n/3 \rfloor\). במילים אחרות, \(g(n)\ge \lfloor n/3 \rfloor\). אך האם זהו המקרה הגרוע ביותר? האם \(\lfloor n/3 \rfloor\) מצלמות תמיד מספיקות כדי לשמור על פוליגון בגודל \(n\)? את זה נגלה בחלק הבא.

\hypertarget{guarding}{%
\section{שמירה ושילושים}\label{guarding}}

\hypertarget{diagonals}{%
\subsection{חלוקה בעזרת אלכסונים}\label{diagonals}}

בניגוד לשמו, פוליגון פשוט עשוי להיות צורה מסובכת מאוד, ראו למשל את הדוגמה באיור משמאל. היצוג של פוליגון כסדרה של נקודות הוא אמנם פשוט, אך לעיתים קרובות נרצה לעבוד דווקא עם ייצוג מורכב יותר, שיעזור לנו להבין טוב יותר את המבנה של הפוליגון. לדוגמה, כיצד נוכל לחשב את השטח של פוליגון פשוט? דרך אחת לעשות זאת היא לחלק את הפוליגון לצורות בסיסיות יותר, כמו משולשים או מרובעים, עבורן אנו יכולים לחשב את השטח בקלות. חלוקה כזאת ניתן לקבל למשל על-ידי הוספת אלכסונים לפוליגון.

\ul{\textbf{הגדרה}: אלכסון של פוליגון}\\
אלכסון של פוליגון P הוא קטע פתוח המחבר שני קודקודים של P ומוכל בפנימו.

\ul{דוגמה:\\
}התבוננו בפוליגונים שבאיור הבא, כולם בעלי 5 קודקודים, ואלכסוניהם מסומנים בקו מקווקו. לפוליגון מימין קיימים שלושה אלכסונים. לפוליגון האמצעי לעומת זאת יש רק שני אלכסונים. באופן כללי, בפוליגון בעל 5 קודקודים קיימים לכל היותר 5 אלכסונים. ניתן לראות זאת בפוליגון משמאל.

מהו מספר האלכסונים המקסימלי האפשרי בפוליגון בעל n קודקודים?

(פתרון)

שימו לב למקרה של פוליגון קמור: מכל קודקוד ניתן למתוח \(n-3\) אלכסונים (לכל קודקוד שהוא לא הוא עצמו או אחד משכניו). מכיוון שבאופן זה כל אלכסון נספר פעמיים (פעם אחת לכל אחד מקודקודיו), נחלק ב-2. לכן, התשובה היא \(\frac{n(n-3)}{2}\).

\hypertarget{triangulation}{%
\subsection{שילוש של פוליגונים}\label{triangulation}}

שילוש של פוליגונים הוא כלי מרכזי וחשוב בגיאומטריה של המישור, ויש לו שימוש רבים, בעיקר בתחום של גרפיקה ממוחשבת.

\ul{\textbf{הגדרה}: שילוש (טריאנגולציה}\\
לחלוקה של פוליגון למשולשים על-ידי מספר מקסימלי של אלכסונים שאינם נחתכים אנו קוראים בשם שילוש (טריאנגולציה).

\ul{דוגמה:\\
}בדרך כלל קיים יותר משילוש אחד לפוליגון. למשל, את הפוליגון באיור הבא ניתן לשלש במספר דרכים שונות. נסו למצוא שילוש השונה מהשניים המוצעים כאן.

\hypertarget{ux5deux5d3ux5d5ux5e2-ux5e0ux5d3ux5e8ux5d5ux5e9-ux5deux5e1ux5e4ux5e8-ux5deux5e7ux5e1ux5d9ux5deux5dcux5d9-ux5e9ux5dc-ux5d0ux5dcux5dbux5e1ux5d5ux5e0ux5d9ux5dd}{%
\subsubsection*{מדוע נדרוש מספר מקסימלי של אלכסונים?}\label{ux5deux5d3ux5d5ux5e2-ux5e0ux5d3ux5e8ux5d5ux5e9-ux5deux5e1ux5e4ux5e8-ux5deux5e7ux5e1ux5d9ux5deux5dcux5d9-ux5e9ux5dc-ux5d0ux5dcux5dbux5e1ux5d5ux5e0ux5d9ux5dd}}
\addcontentsline{toc}{subsubsection}{מדוע נדרוש מספר מקסימלי של אלכסונים?}

זאת על מנת להבטיח שלא יהיו קודקודים של הפוליגון שאינם קודקודים של אחד המשולשים. מצב כזה יכול לקרות כאשר שלושה קודקודים עוקבים מופיעים על ישר אחד. ראו למשל את שלושת הקודקודים משמאל למטה באיור הקודם.

ראינו דוגמה לפוליגון עם יותר משילוש אחד, אך האם תמיד קיים שילוש? התשובה היא כן! על מנת להוכיח זאת, נראה קודם שתמיד נוכל למצוא אלכסון בפוליגון בעל לפחות 4 קודקודים.

\hypertarget{ux5deux5e9ux5e4ux5d8-ux5dcux5dbux5dc-ux5e4ux5d5ux5dcux5d9ux5d2ux5d5ux5df-ux5e4ux5e9ux5d5ux5d8-ux5d1ux5e2ux5dc-4-ux5e7ux5d5ux5d3ux5e7ux5d5ux5d3ux5d9ux5dd-ux5dcux5e4ux5d7ux5d5ux5ea-ux5e7ux5d9ux5d9ux5dd-ux5d0ux5dcux5dbux5e1ux5d5ux5df.}{%
\subsubsection*{משפט: לכל פוליגון פשוט בעל 4 קודקודים לפחות, קיים אלכסון.}\label{ux5deux5e9ux5e4ux5d8-ux5dcux5dbux5dc-ux5e4ux5d5ux5dcux5d9ux5d2ux5d5ux5df-ux5e4ux5e9ux5d5ux5d8-ux5d1ux5e2ux5dc-4-ux5e7ux5d5ux5d3ux5e7ux5d5ux5d3ux5d9ux5dd-ux5dcux5e4ux5d7ux5d5ux5ea-ux5e7ux5d9ux5d9ux5dd-ux5d0ux5dcux5dbux5e1ux5d5ux5df.}}
\addcontentsline{toc}{subsubsection}{משפט: לכל פוליגון פשוט בעל 4 קודקודים לפחות, קיים אלכסון.}

\textbf{הוכחה}: יהי \(P\) פוליגון בעל \(n\) קודקודים, ויהי \(v\) הקודקוד השמאלי ביותר של \(P\) (במקרה שיש יותר מאחד כזה, נבחר בנמוך ביותר). נסמן ב-\(u,w\) את שני הקודקודים השכנים ל-\(v\) על שפת הפוליגון. אם הקטע הפתוח \(\overline{u w}\) מוכל בפנים של \(P\), אזי מצאנו אלכסון של \(P\). אחרת, קיים לפחות קודקוד אחד של \(P\) בפנימו של המשולש המוגדר על ידי הקודקודים \(u,v,w\), או על הקטע \(\overline{u w}\) (נשים לב כי מבחירת \(v\), הקודקודים \(u, v, w\) לא יכולים להיות כולם על ישר אחד). יהי \(v'\) הקודקוד השמאלי ביותר בתוך המשולש הזה. הקטע \(\overline{v v'}\) לא חותך אף צלע של \(P\), אחרת, אחד מהקודקודים של צלע כזו היה בתוך המשולש ושמאלי יותר מ-\(v\). לכן, הקטע הפתוח \(\overline{v v'}\) הוא אלכסון של \(P\).

\hypertarget{ux5deux5e9ux5e4ux5d8-ux5dcux5dbux5dc-ux5e4ux5d5ux5dcux5d9ux5d2ux5d5ux5df-ux5e7ux5d9ux5d9ux5dd-ux5e9ux5d9ux5dcux5d5ux5e9.}{%
\subsubsection*{משפט: לכל פוליגון קיים שילוש.}\label{ux5deux5e9ux5e4ux5d8-ux5dcux5dbux5dc-ux5e4ux5d5ux5dcux5d9ux5d2ux5d5ux5df-ux5e7ux5d9ux5d9ux5dd-ux5e9ux5d9ux5dcux5d5ux5e9.}}
\addcontentsline{toc}{subsubsection}{משפט: לכל פוליגון קיים שילוש.}

בנוסף, כל שילוש של פוליגון פשוט בעל \(n\) קודקודים מכיל בדיוק \(n-2\) משולשים ו- \(2n-3\) צלעות.

\textbf{הוכחה}: יהי \(P\) פוליגון בעל \(n\) קודקודים. נוכיח את המשפט באינדוקציה על \(n\). עבור \(n=3\), \(P\) הוא משולש והמשפט מתקיים. יהי \(n>3\), ונניח שהמשפט מתקיים לכל \(m<n\). לפי המשפט שהוכחנו קודם, קיים ב-\(P\) אלכסון. כל אלכסון כזה מחלק את \(P\) לשני פוליגונים \(P_1,P_2\). מספר הקודקודים של כל אחד מהפוליגונים האלו קטן ממש מ-\(n\), ולכן לפי הנחת האינדוקציה קיים שילוש של \(P_ 1\) ו-\(P_ 2\), והאיחוד שלהם הוא שילוש של \(P\).\\
כדי לחסום את מספר המשולשים, נתבונן בשילוש כלשהו של \(P\), ונבחר אלכסון \(\overline{uv}\) כלשהו בשילוש (כאשר \(u, v\) הם קודקודים של \(P\)). אלכסון זה מחלק את \(P\) לשני פוליגונים \(P_ 1, P_ 2\), בעלי \(m_ 1, m_ 2\) קודקודים, בהתאמה. כל קודקוד של \(P\) פרט לקודקודים \(u, v\) מופיע בדיוק באחד מ-\(P_ 1, P_ 2\), והקודקודים \(u, v\) מופיעים בשניהם. לכן, מתקיים \(m_1+m_2= n+2\). לפי הנחת האינדוקציה, מספר המשולשים בשילוש של \(P_1\) הוא \(m_1-2\), ומספר המשולשים בשילוש של \(P_2\) הוא \(m_2- 2\). לכן השילוש של מכיל בסך הכל \(m_1-2+ m_2-2 = n- 2\) משולשים.\\
באופן דומה, כל אלכסון בשילוש של \(P\) פרט ל-\(\overline{u v}\) מופיע בדיוק באחד מהשילושים של \(P_1, P_2\), והאלכסון \(\overline{u v }\) מופיע כצלע בשניהם. לכן לפי הנחת האינדוקציה, מספר הצלעות בשילוש של \(P\) הוא \((2m_1 - 3)+ (2m_2- 3 )- 1 = 2 (m_1+m_2)-7=2(n+2)-7=2n-3\).

\hypertarget{ux5deux5e6ux5d9ux5d0ux5ea-ux5e9ux5d9ux5dcux5d5ux5e9.}{%
\subsubsection*{מציאת שילוש.}\label{ux5deux5e6ux5d9ux5d0ux5ea-ux5e9ux5d9ux5dcux5d5ux5e9.}}
\addcontentsline{toc}{subsubsection}{מציאת שילוש.}

אז אמנם ראינו ששילוש קיים תמיד, אך כדי להשתמש בו נרצה גם להראות אלגוריתם שיודע למצוא שילוש ביעילות.

שאלה למחשבה: השתמשו בהוכחות המשפטים המופיעות למעלה, על מנת להראות אלגוריתם המוצא שילוש של פוליגון פשוט בעל \(n\) קודקודים בזמן \(O(n^2)\).

בהמשך נראה אלגוריתם יעיל יותר למציאת שילוש, עם זמן ריצה של \(O(n \log n)\), ו-\(O(n)\) זיכרון.

\hypertarget{dual-graph}{%
\subsection{הגרף הדואלי לשילוש}\label{dual-graph}}

תכונה מעניינת (ושימושית!) נוספת של שילושים מתקבלת כשמתבוננים בגרף הדואלי לשילוש. למעשה, היצוג של שילוש באמצעות גרף מאפשר לנו לתרגם את הבעיה הגאומטרית לבעיה קומבינטורית.

נסמן ב-\(T\) את אוסף המשולשים בשילוש כלשהו של פוליגון \(P\). הגרף הדואלי \(G_T\) לשילוש \(T\) הוא הגרף שקבוצת הקודקודים שלו מכילה קודקוד אחד לכל משולש ב-\(T\), וקבוצת הצלעות שלו מכילה צלע בין שני קודקודים \(u,v\) של הגרף אם המשולשים המתאימים לקודקודים אלו חולקים אלכסון משותף.

\ul{דוגמה:\\
}באיור למטה ניתן לראות שילוש \(T\) ואת הגרף \(G_T\) המתאים לו.

כל קודקוד של \(G_T\) מתאים למשולש מ-\(T\), וכל צלע של \(G_T\) מתאימה לאלכסון בשילוש (כל צלע חוצה אלכסון אחד). שימו לב שהגרף \(G_T\) הוא עץ. האם זה מקרי?

\hypertarget{ux5d0ux5d1ux5d7ux5e0ux5d4-ux5d4ux5d2ux5e8ux5e3-ux5d4ux5d3ux5d5ux5d0ux5dcux5d9-ux5dcux5e9ux5d9ux5dcux5d5ux5e9-ux5d4ux5d5ux5d0-ux5e2ux5e5.}{%
\subsubsection*{אבחנה: הגרף הדואלי לשילוש הוא עץ.}\label{ux5d0ux5d1ux5d7ux5e0ux5d4-ux5d4ux5d2ux5e8ux5e3-ux5d4ux5d3ux5d5ux5d0ux5dcux5d9-ux5dcux5e9ux5d9ux5dcux5d5ux5e9-ux5d4ux5d5ux5d0-ux5e2ux5e5.}}
\addcontentsline{toc}{subsubsection}{אבחנה: הגרף הדואלי לשילוש הוא עץ.}

נראה שלכל שילוש \(T\), הגרף הדואלי \(G_T\) הוא עץ.

\textbf{הוכחה}: ראשית, נשים לב שהגרף \(G_T\) הוא קשיר מכיוון שפנים הפוליגון קשיר. שנית, כל אלכסון מחלק את \(P\) לשני פוליגונים, לכן מחיקה של צלע מהגרף \(G_T\) מחלקת את הגרף לשני רכיבי קשירות. במילים אחרות, הגרף \(G_T\) הוא קשיר ואינו מכיל מעגלים, כלומר, הוא עץ.

שימו לב: טענה זו אינה נכונה עבור פוליגון עם חורים! הגרף הדואלי לשילוש של \ul{פוליגון עם חורים} עשוי להכיל מעגלים, כמו באיור למטה.

חישבו, מדוע זה קורה? אילו אלכסונים אינם מחלקים את הפוליגון לשני חלקים?

\hypertarget{agp-thm}{%
\subsection{משפט הגלריה לאמנות}\label{agp-thm}}

ראינו קודם שכדי לשמור על פוליגון מסרק עם \(n\) קודקודים, נזדקק ל-\(\lfloor \frac{n}{3} \rfloor\) מצלמות. במילים אחרות, זה אומר ש-\(g(n)\ge \lfloor \frac{n}{3} \rfloor\). האם זהו המקרה הגרוע ביותר? כלומר, האם \(\lfloor \frac{n}{3} \rfloor\) מצלמות יספיקו לכל פוליגון בגודל \(n\) שנבחר? או שקיימיים פוליגונים ``גרועים'' יותר?

התשובה היא שתמיד ניתן להסתפק ב-\(\lfloor \frac{n}{3} \rfloor\) מצלמות! כלומר, נוכל להראות שמתקיים \(g(n)\le \lfloor \frac{n}{3} \rfloor\), ובכך להוכיח את המשפט המפורסם:

\hypertarget{ux5deux5e9ux5e4ux5d8-ux5d4ux5d2ux5dcux5e8ux5d9ux5d4-ux5dcux5d0ux5deux5e0ux5d5ux5ea-gnlfloor-fracn3-rfloor.}{%
\subsubsection*{\texorpdfstring{משפט הגלריה לאמנות: \(g(n)=\lfloor \frac{n}{3} \rfloor\).}{משפט הגלריה לאמנות: g(n)=\textbackslash lfloor \textbackslash frac\{n\}\{3\} \textbackslash rfloor.}}\label{ux5deux5e9ux5e4ux5d8-ux5d4ux5d2ux5dcux5e8ux5d9ux5d4-ux5dcux5d0ux5deux5e0ux5d5ux5ea-gnlfloor-fracn3-rfloor.}}
\addcontentsline{toc}{subsubsection}{משפט הגלריה לאמנות: \(g(n)=\lfloor \frac{n}{3} \rfloor\).}

\textbf{מעניין לדעת}: הראשון לנסח ולהוכיח את משפט הגלריה לאמנות היה ואצלב כבטל (Václav Chvátal), אך את ההוכחה שנראה כאן גילה סטיב פיסק (Steve Fisk). ההוכחה של פיסק היתה קצרה ופשוטה יותר, ונחשבה אלגנטית כל כך עד שנכללה בספר ``Proofs from the BOOK'' - אוסף של הוכחות בהשראת אמרתו של פול ארדש (Paul Erdős): ``a place where God keeps aesthetically perfect proofs''.

לפני שנראה את ההוכחה לכך ש-\(\lfloor \frac{n}{3} \rfloor\) מצלמות מספיקות תמיד, ננסה להבין כיצד ניתן להוכיח חסמים פשוטים יותר. כיצד ניתן להראות שמספר מסויים של מצלמות מספיק לכל פוליגון \(P\) בעל \(n\) קודקודים?

\ul{דוגמה:\\
}נתבונן בשילוש של \(P\). קל להראות שמספיקות \(n\) מצלמות המוצבות על קודקודי \(P\), מדוע?

קודקודי המשולשים הם קודקודים של \(P\), ומשולש הוא פוליגון קמור, ולכן קבוצה זו של מצלמות שומרת על כל \(P\). למעשה, מכיוון שבכל שילוש יש \(n-2\) משולשים, נוכל להסתפק ב-\(n-2\) מצלמות.

כעת נראה הוכחה למשפט הגלריה לאמנות. אולי בשלב זה כבר ניחשתם כי הוכחה זו מבוססת גם היא על שילוש של הפוליגון. בנוסף לשילוש, ההוכחה תתבסס גם על צביעה של הגרף המוגדר על-ידי צלעות המשולשים וקודקודי הפוליגון (זהו לא הגרף הדואלי). נזכיר כי גרף הוא \(k\)-צביע (ניתן לצביעה ב-\(k\) צבעים) אם ניתן להתאים לכל אחד מקודקודיו צבע (מספר) בין 1 ל-\(k\) כך שכל שני קודקודים המחוברים בצלע משותפת צבועים בצבעים שונים.

\hypertarget{ux5d8ux5e2ux5e0ux5d4-ux5dbux5dc-ux5e9ux5d9ux5dcux5d5ux5e9-ux5e0ux5d9ux5eaux5df-ux5dcux5e6ux5d1ux5d9ux5e2ux5d4-ux5d1ux5e9ux5dcux5d5ux5e9ux5d4-ux5e6ux5d1ux5e2ux5d9ux5dd.}{%
\subsubsection*{טענה: כל שילוש ניתן לצביעה בשלושה צבעים.}\label{ux5d8ux5e2ux5e0ux5d4-ux5dbux5dc-ux5e9ux5d9ux5dcux5d5ux5e9-ux5e0ux5d9ux5eaux5df-ux5dcux5e6ux5d1ux5d9ux5e2ux5d4-ux5d1ux5e9ux5dcux5d5ux5e9ux5d4-ux5e6ux5d1ux5e2ux5d9ux5dd.}}
\addcontentsline{toc}{subsubsection}{טענה: כל שילוש ניתן לצביעה בשלושה צבעים.}

הוכחה: נוכיח את המשפט באינדוקציה על מספר הקודקודים \(n\). עבור \(n=3\)., הפוליגון הוא משולש וניתן לצביעה בשלושה צבעים. יהי \(n> 3\), ונניח שהמשפט מתקיים לכל \(m<n\). יהי \(P\) פוליגון בעל \(n\) קודקודים, נתבונן בשילוש כלשהו של \(P\), ונבחר אלכסון \(overline{u v}\) כלשהו בשילוש (כאשר \(u,v\) הם קודקודים של \(P\)). אלכסון זה מחלק את \(P\) לשני פוליגונים \(P_1,P_2\). לפי הנחת האינדוקציה, נוכל לצבוע את \(P_1\)בשלושה צבעים: אדום, כחול, וצהוב, ואת \(P_2\) בצבעים: כתום, סגול, וירוק. כעת נרצה ``להדביק'' את שני הפוליגונים כך שנקבל צכיעה של \(P\). מכיוון שבחירת הצבעים היא שרירותית, נוכל להניח בלי הגבלת הכלליות שבצביעה של \(P_1\) הקודקודים \(u,v\) נצבעו באדום וכחול בהתאמה, ובצביעה של \(P_2\) הם נצבעו בכתום וסגול בהתאמה. לכן נחליף את הצבע של כל קודקוד כתום לאדום, סגול לכחול, וירוק לצהוב. קיבלנו צביעה של \(P\) בשלושה צבעים.

\hypertarget{ux5deux5e9ux5e4ux5d8-gnle-lfloor-fracn3-rfloor.}{%
\subsubsection*{\texorpdfstring{משפט: \(g(n)\le \lfloor \frac{n}{3} \rfloor\).}{משפט: g(n)\textbackslash le \textbackslash lfloor \textbackslash frac\{n\}\{3\} \textbackslash rfloor.}}\label{ux5deux5e9ux5e4ux5d8-gnle-lfloor-fracn3-rfloor.}}
\addcontentsline{toc}{subsubsection}{משפט: \(g(n)\le \lfloor \frac{n}{3} \rfloor\).}

כלומר, ניתן לשמור על כל פוליגון פשוט \(P\) בעל \(n\) קודקודים בעזרת \(\lfloor \frac{n}{3} \rfloor\) מצלמות.

הוכחה: נבחר שילוש כלשהו \(T\) של \(P\) ונצבע אותו בשלושה צבעים: אדום, כחול, וצהוב. מעיקרון שובך היונים, קיים לפחות צבע אחד שבו צבועים לכל היותר \(\lfloor \frac{n}{3} \rfloor\) קודקודים (אחרת, נקבל שסכום הקודקודים גדול מ-\(n\)). נניח שצבע זה הוא האדום, ונמקם מצלמה בכל קודקוד הצבוע באדום. נשים לב שבכל משולש ב-T יש בדיוק קודקוד אחד הצבוע באדום: אחרת, נקבל צלע ששני קודקודיה צבועים באותו הצבע. מכיוון שכל משולש הוא קמור, המצלמה הממוקמת על הקודקוד האדום שומרת על כולו, ולכן המצלמות שהצבנו שומרות על כל P.

\hypertarget{ux5d2ux5dcux5e8ux5d9ux5d5ux5ea-ux5d0ux5d5ux5e8ux5eaux5d5ux5d2ux5d5ux5e0ux5dcux5d9ux5d5ux5ea.}{%
\subsubsection*{גלריות אורתוגונליות.}\label{ux5d2ux5dcux5e8ux5d9ux5d5ux5ea-ux5d0ux5d5ux5e8ux5eaux5d5ux5d2ux5d5ux5e0ux5dcux5d9ux5d5ux5ea.}}
\addcontentsline{toc}{subsubsection}{גלריות אורתוגונליות.}

עבור פוליגון פשוט אורתוגונלי, ניתן להראות כי מספיקים \(\lfloor \frac{n}{4} \rfloor\) שומרים. קווי ההוכחה דומים: תחילה ``מרבעים'' את הפוליגון, כלומר מחלקים את הפוליגון למרובעים קמורים בעזרת אלכסונים. לאחר מכן, מוסיפים לכל מרובע את שני האלכסונים שלו (שימו לב שהאלכסונים חוצים זה את זה), ולבסוף מראים שקיימת צביעה של הגרף שהתקבל בארבעה צבעים. מכאן לפי עקרון שובך היונים, קיים צבע אחד שהשתמשנו בו לכל היותר \(\lfloor \frac{n}{4} \rfloor\) פעמים, ומכיוון שלכל אחד מהמרובעים יש בדיוק קודקוד אחד הצבוע בצבע זה, קיבלנו קבוצה של מצלמות ששומרות על הפוליגון כולו.

\hypertarget{ux5dcux5d7ux5d6ux5e8ux5d4-ux5e7ux5e8ux5d9ux5d0ux5d4-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3}{%
\subsection{לחזרה: קריאה בספר הלימוד}\label{ux5dcux5d7ux5d6ux5e8ux5d4-ux5e7ux5e8ux5d9ux5d0ux5d4-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3}}

בסעיפים הקודמים של חלק זה ראינו הוכחות מלאות לקיום של שילוש ומשפט הגלריה לאמנות. לשם השלמות של החומר באתר, ולמי שמעוניין בחזרה והרחבה, ניתן לקרוא כאן את הסעיף המתאים בספר הלימוד.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-3.1-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-4649.}{%
\subsubsection*{קראו את סעיף 3.1 בספר (עמודים 46--49).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-3.1-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-4649.}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 3.1 בספר (עמודים 46--49).}

\hypertarget{ux5d0ux5dcux5d2ux5d5ux5e8ux5d9ux5eaux5dd-ux5dcux5e9ux5d9ux5dcux5d5ux5e9-ux5e9ux5dc-ux5e4ux5d5ux5dcux5d9ux5d2ux5d5ux5df}{%
\section{אלגוריתם לשילוש של פוליגון}\label{ux5d0ux5dcux5d2ux5d5ux5e8ux5d9ux5eaux5dd-ux5dcux5e9ux5d9ux5dcux5d5ux5e9-ux5e9ux5dc-ux5e4ux5d5ux5dcux5d9ux5d2ux5d5ux5df}}

\hypertarget{ux5d0ux5d9ux5da-ux5e0ux5d7ux5e9ux5d1-ux5e9ux5d9ux5dcux5d5ux5e9}{%
\subsection{איך נחשב שילוש?}\label{ux5d0ux5d9ux5da-ux5e0ux5d7ux5e9ux5d1-ux5e9ux5d9ux5dcux5d5ux5e9}}

בחלק הקודם ראינו ששילוש קיים תמיד, אך כדי להשתמש בו, נרצה גם להראות אלגוריתם שיודע למצוא שילוש ביעילות.

שימו לב שההוכחות לקיום אלכסון ושילוש שראינו בחלק הקודם הן \textbf{קונסטרוקטיביות}, כלומר הן מציגות דרך למציאה של אלכסון ושילוש של פוליגון פשוט בעל \(n\) קודקודים בזמן \(O(n^2)\).

נסו לחשוב בעצמכם: השתמשו בהוכחות המשפטים לקיום אלכסון ושילוש על מנת להראות אלגוריתם המוצא שילוש של פוליגון פשוט בעל \(n\) קודקודים בזמן \(O(n^2)\). (התשובה מופיעה בפסקה הראשונה של פרק 3.2 בספר הלימוד)

\hypertarget{ux5d4ux5d0ux5dd-ux5e0ux5d9ux5eaux5df-ux5dcux5deux5e6ux5d5ux5d0-ux5d0ux5dcux5d2ux5d5ux5e8ux5d9ux5eaux5dd-ux5e9ux5d9ux5dcux5d5ux5e9-ux5d9ux5e2ux5d9ux5dc-ux5d9ux5d5ux5eaux5e8}{%
\subsubsection*{האם ניתן למצוא אלגוריתם שילוש יעיל יותר?}\label{ux5d4ux5d0ux5dd-ux5e0ux5d9ux5eaux5df-ux5dcux5deux5e6ux5d5ux5d0-ux5d0ux5dcux5d2ux5d5ux5e8ux5d9ux5eaux5dd-ux5e9ux5d9ux5dcux5d5ux5e9-ux5d9ux5e2ux5d9ux5dc-ux5d9ux5d5ux5eaux5e8}}
\addcontentsline{toc}{subsubsection}{האם ניתן למצוא אלגוריתם שילוש יעיל יותר?}

בהחלט ניתן למצוא שילוש ביעילות עבור משפחות מסויימות של פוליגונים מיוחדים. למשל, אם הפוליגון שלנו קמור, נוכל לבחור קודקוד באופן שרירותי, ולהוסיף את כל האלכסונים המחברים אותו לכל הקודקודים שהם לא שכנים שלו. זמן הריצה יהיה לינארי, כלומר \(O(n)\).

לכן, גישה אפשרית למציאת שילוש במקרה הכללי תהיה כזו: נחלק את הפוליגון שלנו לחלקים שניתן לשלש ביעילות, ולאחר מכן נשלש כל חלק בנפרד.

בסעיפים הבאים נראה אלגוריתם למציאת שילוש שמשתמש בגישה הזו, על ידי חלוקה של הפוליגון לחלקים מונוטוניים. זמן הריצה של האלגוריתם הוא \(O(n \log n)\), והוא משתמש ב-\(O(n)\) זיכרון.

\ul{\textbf{הגדרה}: פוליגון מונוטוני}\\
פוליגון פשוט \(P\) נקרא \textbf{מונוטוני ביחס לישר} \(\ell\) אם לכל ישר \(\ell'\) שמאונך ל-\(\ell\), החיתוך של \(\ell'\)עם הפוליגון הוא קשיר. במילים אחרות, \(\ell'\cap P\) יכול להיות קטע, נקודה, או הקבוצה הריקה.

פוליגון שהוא מונוטוני ביחס לציר ה-\(y\) נקרא \(y\)-מונוטוני.

אילו מהפוליגונים הבאים הם \(y\)-מונוטוניים? ואילו \(x\)-מונוטוניים?

(פתרון)

(א) הוא גם \(y\)-מונוטוני וגם \(x\)-מונוטוני (ד) הוא רק \(x\)-מונוטוני (ה) הוא רק \(y\)-מונוטוני

\hypertarget{ux5d7ux5dcux5d5ux5e7ux5d4-ux5dcux5e4ux5d5ux5dcux5d9ux5d2ux5d5ux5e0ux5d9ux5dd-ux5deux5d5ux5e0ux5d5ux5d8ux5d5ux5e0ux5d9ux5d9ux5dd}{%
\subsection{חלוקה לפוליגונים מונוטוניים}\label{ux5d7ux5dcux5d5ux5e7ux5d4-ux5dcux5e4ux5d5ux5dcux5d9ux5d2ux5d5ux5e0ux5d9ux5dd-ux5deux5d5ux5e0ux5d5ux5d8ux5d5ux5e0ux5d9ux5d9ux5dd}}

בסרטון הבא נדבר על אלגוריתם MakeMonotone, המוצא חלוקה של פוליגון \(P\) בעל \(n\) קודקודים לפוליגונים \(y\)-מונוטוניים. האלגוריתם משתמש בשיטת הישר הסורק שלמדנו בחלק השני של פרק 2, ולכן מומלץ להיזכר ולוודא קודם שהבנתם את הפרטים של שיטה זו.

\hypertarget{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0.-3}{%
\subsubsection*{צפו בסרטון הבא.}\label{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0.-3}}
\addcontentsline{toc}{subsubsection}{צפו בסרטון הבא.}

~\\
הנה התשובה לשאלה האחרונה שנשאלה בסרטון: היצוג של \(P\) ותתי הפוליגונים המונוטוניים בחלוקה שלו יהיה בעזרת מבנה DCEL, כפי שלמדנו בחלק השלישי של פרק 2.

כיצד נממש את האלגוריתם הסורק ביעילות? על אופן המימוש ופרטי האלגוריתם MakeMonotone תקראו בסעיף 3.2 של ספר הלימוד. זמן הריצה של האלגוריתם הוא \(O(n \log n)\), והוא משתמש ב-\(O(n)\) זיכרון.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-3.2-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-4955.}{%
\subsubsection*{קראו את סעיף 3.2 בספר (עמודים 49--55).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-3.2-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-4955.}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 3.2 בספר (עמודים 49--55).}

\hypertarget{ux5e9ux5d9ux5dcux5d5ux5e9-ux5e9ux5dc-ux5e4ux5d5ux5dcux5d9ux5d2ux5d5ux5df-ux5deux5d5ux5e0ux5d5ux5d8ux5d5ux5e0ux5d9}{%
\subsection{שילוש של פוליגון מונוטוני}\label{ux5e9ux5d9ux5dcux5d5ux5e9-ux5e9ux5dc-ux5e4ux5d5ux5dcux5d9ux5d2ux5d5ux5df-ux5deux5d5ux5e0ux5d5ux5d8ux5d5ux5e0ux5d9}}

לאחר שראינו כיצד ניתן לחלק פוליגון פשוט בעל \(n\) קודקודים לפוליגונים \(y\)-מונוטוניים בזמן \(O(n \log n)\), נותר לנו להראות שכל פוליגון מונוטוני ניתן לשילוש בזמן לינארי.

\hypertarget{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0.-4}{%
\subsubsection*{צפו בסרטון הבא.}\label{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0.-4}}
\addcontentsline{toc}{subsubsection}{צפו בסרטון הבא.}

~\\
בסעיף 3.3 של ספר הלימוד תקראו בפירוט רב יותר על האלגוריתם TriangulateMonotonePolygons שתואר בסרטון. זמן הריצה של האלגוריתם הזה הוא אכן \(O(n)\), ומכאן שקיבלנו אלגוריתם שילוש בזמן - שיפור משמעותי לעומת האלגוריתם בזמן ריבועי (\(O(n^2)\)) המבוסס על ההוכחה לקיום שילוש. למעשה, נוכל להסיק שכל מפה מישורית עם \(n\) קודקודים ניתנת לשילוש בזמן !

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-3.3-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-55-58.}{%
\subsubsection*{קראו את סעיף 3.3 בספר (עמודים 55-58).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-3.3-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-55-58.}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 3.3 בספר (עמודים 55-58).}

\hypertarget{ux5eaux5dbux5e0ux5d5ux5df-ux5dcux5d9ux5e0ux5d9ux5d0ux5e8ux5d9-ux5d5ux5d7ux5d9ux5eaux5d5ux5da-ux5e9ux5dc-ux5d7ux5e6ux5d0ux5d9-ux5deux5d9ux5e9ux5d5ux5e8ux5d9ux5dd}{%
\chapter{תכנון ליניארי וחיתוך של חצאי מישורים}\label{ux5eaux5dbux5e0ux5d5ux5df-ux5dcux5d9ux5e0ux5d9ux5d0ux5e8ux5d9-ux5d5ux5d7ux5d9ux5eaux5d5ux5da-ux5e9ux5dc-ux5d7ux5e6ux5d0ux5d9-ux5deux5d9ux5e9ux5d5ux5e8ux5d9ux5dd}}

\hypertarget{ux5d4ux5e7ux5d3ux5deux5d4}{%
\section{הקדמה}\label{ux5d4ux5e7ux5d3ux5deux5d4}}

\hypertarget{ux5d1ux5e2ux5d9ux5d9ux5ea-ux5d4ux5d9ux5d9ux5e6ux5d5ux5e8-ux5d1ux5d0ux5deux5e6ux5e2ux5d5ux5ea-ux5eaux5d1ux5e0ux5d9ux5d5ux5ea}{%
\subsection{בעיית הייצור באמצעות תבניות}\label{ux5d1ux5e2ux5d9ux5d9ux5ea-ux5d4ux5d9ux5d9ux5e6ux5d5ux5e8-ux5d1ux5d0ux5deux5e6ux5e2ux5d5ux5ea-ux5eaux5d1ux5e0ux5d9ux5d5ux5ea}}

חפצים רבים שאנו משתמשים בהם באופן יום-יומי מיוצרים בתהליך אוטומטי, שבו יוצקים נוזל לתבנית רב פעמית, ולאחר שהוא מתמצק שולפים אותו החוצה מבלי לפגוע בתבנית. כמובן שלא כל צורה תלת מימדית ניתנת לייצור באופן הזה, למשל צורה שהיא כדורית. נניח שנתון לנו \textbf{פוליהדרון} (גוף תלת מימדי המורכב מפאות שהן פוליגונים, צלעות שהן קוים ישרים, וקודקודים שהם נקודות), איך נדע האם ניתן לייצר אותו על ידי יציקה לתבנית רב פעמית?

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d4ux5d4ux5e7ux5d3ux5deux5d4-ux5dcux5e4ux5e8ux5e7-4-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-63-64.}{%
\subsubsection*{קראו את ההקדמה לפרק 4 (עמודים 63-64).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d4ux5d4ux5e7ux5d3ux5deux5d4-ux5dcux5e4ux5e8ux5e7-4-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-63-64.}}
\addcontentsline{toc}{subsubsection}{קראו את ההקדמה לפרק 4 (עמודים 63-64).}

\hypertarget{ux5deux5d5ux5d3ux5dc-ux5d2ux5d0ux5d5ux5deux5d8ux5e8ux5d9-ux5dcux5d1ux5e2ux5d9ux5d4}{%
\subsection{מודל גאומטרי לבעיה}\label{ux5deux5d5ux5d3ux5dc-ux5d2ux5d0ux5d5ux5deux5d8ux5e8ux5d9-ux5dcux5d1ux5e2ux5d9ux5d4}}

בהינתן פוליהדרון \(P\) בעל \(n\) פאות שהן פוליגונים, נרצה לתכנן תבנית שתאפשר לנו לייצר את \(P\). כדי שנוכל לחלץ את \(P\) מהתבנית על ידי משיכה בכיוון אחד, נדרוש שבדיוק אחת מהפאות של \(P\) תהיה מוכלת בפאה העליונה של התבנית. התבנית חייבת להתאים לצורה של \(P\), אבל את הפאה העליונה נוכל לבחור מתוך \(n\) הפאות של \(P\), ולכן יש לכל היותר \(n\) תבניות אפשרויות. כמובן שלא כל תבנית תאפשר לנו לחלץ את \(P\).

בדיקת שפיות! ענו על השאלה הבאה: באילו מהתבניות הבאות ניתן לחלץ את הפוליהדרון שיצקו בהן על ידי משיכה בכיוון אחד?

(לשם הפשטות, האיורים מציגים חתך עומק של התבנית והפוליהדרון בדו-מימד. הניחו שכל חתכי העומק של הפוליהדרון זהים לזה שבאיור.)

(פתרון)

שלושת התבניות הראשונות משמאל.

אובייקט שניתן לייצור על ידי יציקה לתבנית רב פעמית נקרא castable. כדי לבדוק האם \(P\) הוא castable, נבדוק את כל האפשרויות לתבנית עבורו. בהינתן אחת מהאפשרויות האלה (כלומר, בהינתן הפאה של \(P\) שתהיה מוכלת בפאה העליונה של התבנית), נרצה לקבוע האם קיים כיוון (וקטור) \(\overrightarrow{d}\) כך שניתן לשלוף את \(P\) מהתבנית על ידי משיכה בכיוון \(\overrightarrow{d}\).

שימו לב שלכל פאה \(f\) של \(P\) שהיא לא הפאה העליונה, יש פאה מתאימה \(\hat{f}\) בתבנית. באופן אינטואיטיבי, כדי שנוכל להוציא את \(P\) מהתבנית, כל פאה \(f\) של \(P\) צריכה לנוע בכיוון שהוא ``נגדי'' או לכל היותר ``מאונך'' ל-\(\hat{f}\). באופן פורמלי, נוכל להסתכל על הנורמל (כלפי חוץ מהפוליגון) של פאה \(f\), נסמן אותו \(\overrightarrow{\mu}( f )\). הנורמל של \(f\) הוא וקטור המאונך למישור המכיל את \(f\). נוכל להראות שהפאה המתאימה \(\hat{f}\) של התבנית, מאפשרת תנועה רק בכיוון \(\overrightarrow{d}\) שבו הזווית (הקטנה) שנוצרת בין \(\overrightarrow{d}\) ל-\(\overrightarrow{\mu}( f )\) היא לפחות \(90 ^\circ\).

הטענה הזו מובילה להגדרת הבעיה באופן הבא: יש למצוא כיוון \(\overrightarrow{d}\) כך שהזוית שלו עם הנורמלים של כל אחת מהפאות של \(P\) היא לפחות \(90 ^\circ\). כל פאה של P בעצם מהווה אילוץ על הכיוון \(\overrightarrow{d}\). כל אילוץ כזה ניתן לתאר ע''י משוואה לינארית: הזוית בין \(\overrightarrow{d}\) ל-\(\overrightarrow{\mu}( f )\) גדולה או שווה ל-\(90 ^\circ\) אם ורק אם \(\overrightarrow{d} \cdot \overrightarrow{\mu}( f ) \le 0\). נוכל לייצג את \(\overrightarrow{d}\) על ידי נקודה במישור \(z = 1\), כלומר, \(\overrightarrow{d}\) יהיה הוקטור \((x,y,1)\) מתחיל בראשית הצירים ומסתיים בנקודה \((x, y, 1 )\). לכן עבור \(\overrightarrow{\mu}( f ) =( \mu_x, \mu_y, \mu_z )\) נקבל אילוץ שהוא בעצם משוואה של חצי מישור: \(\mu_x \cdot x + \mu_y \cdot y + \mu_z \le 0\).

המשמעות היא שקיים כיוון \(\overrightarrow{d}\) המאפשר לשלוף את \(P\) מהתבנית, אם ורק אם קיימת נקודה \(( x, y )\) המקיימת כל כל האילוצים, כלומר, נקודה שנמצאת בחיתוך של אוסף חצאי המישורים המתאימים להם. בעצם המרנו את הבעיה המקורית לבעיה גאומטרית במישור: בהינתן אוסף של n חצאי מישורים, יש למצוא נקודה בחיתוך שלהם, אם החיתוך לא ריק. בהמשך נראה כיצד ניתן לפתור את הבעיה הזו בזמן צפוי \(O ( n )\), ולכן נוכל לפתור את בעיית הייצור באמצעות תבניות בזמן צפוי \(O ( n^2 )\).

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-4.1-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-64-66.}{%
\subsubsection*{קראו את סעיף 4.1 בספר (עמודים 64-66).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-4.1-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-64-66.}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 4.1 בספר (עמודים 64-66).}

\hypertarget{ux5d7ux5d9ux5eaux5d5ux5da-ux5e9ux5dc-ux5d7ux5e6ux5d0ux5d9-ux5deux5d9ux5e9ux5d5ux5e8ux5d9ux5dd}{%
\section{חיתוך של חצאי מישורים}\label{ux5d7ux5d9ux5eaux5d5ux5da-ux5e9ux5dc-ux5d7ux5e6ux5d0ux5d9-ux5deux5d9ux5e9ux5d5ux5e8ux5d9ux5dd}}

\hypertarget{ux5d0ux5dcux5d2ux5d5ux5e8ux5d9ux5eaux5dd-ux5d1ux5e9ux5d9ux5d8ux5ea-ux5d4ux5e4ux5e8ux5d3-ux5d5ux5deux5e9ux5d5ux5dc}{%
\subsection{אלגוריתם בשיטת הפרד ומשול}\label{ux5d0ux5dcux5d2ux5d5ux5e8ux5d9ux5eaux5dd-ux5d1ux5e9ux5d9ux5d8ux5ea-ux5d4ux5e4ux5e8ux5d3-ux5d5ux5deux5e9ux5d5ux5dc}}

בחלק הקודם ראינו כיצד ניתן להמיר את הבעיה של ייצור באמצעות תבניות לבעיה של מציאת נקודה כלשהי המספקת אוסף של אילוצים לינאריים בשני משתנים, או לחילופין, לבעיה הגאומטרית של מציאת נקודה כלשהי בחיתוך של אוסף חצאי מישורים. החיתוך של אוסף חצאי מישורים הוא תחום קמור, אך הוא אינו חייב להיות חסום. הנה דוגמה לתחום קמור שאינו חסום (מימין), ותחום קמור חסום (משמאל).

לפני שנדבר על הבעיה של מציאת נקודה כלשהי בחיתוך, נראה קודם כיצד ניתן למצוא את קבוצת כל הנקודות בחיתוך. בחלקו הראשון של סעיף 4.2 בספר הלימוד תקראו על אלגוריתם IntersectHalfPlanes, המקבל כקלט אוסף \(H\) של חצאי מישורים, ומחשב את התחום הקמור שהוא החיתוך שלהם. זהו אלגוריתם הפועל בשיטת הפרד ומשול: הוא מחלק את הקבוצה \(H\) באופן שרירותי לשתי קבוצות, מחשב את החיתוך של כל אחת מהן באופן רקורסיבי, ולאחר מכן מחשב את החיתוך של שני התחומים הקמורים שהתקבלו בעזרת פרוצדורה נוספת בשם IntesectConvexRegions.

את אלגוריתם IntersectConvexRegions לחישוב החיתוך בין תחומים קמורים נתאר בהמשך החלק הזה.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e8ux5d0ux5e9ux5d5ux5df-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-4.2-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-6668.}{%
\subsubsection*{קראו את חלקו הראשון של סעיף 4.2 בספר הלימוד (עמודים 66--68).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e8ux5d0ux5e9ux5d5ux5df-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-4.2-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-6668.}}
\addcontentsline{toc}{subsubsection}{קראו את חלקו הראשון של סעיף 4.2 בספר הלימוד (עמודים 66--68).}

\hypertarget{ux5d7ux5d9ux5eaux5d5ux5da-ux5e9ux5dc-ux5e4ux5d5ux5dcux5d9ux5d2ux5d5ux5e0ux5d9ux5dd-ux5e7ux5deux5d5ux5e8ux5d9ux5dd}{%
\subsection{חיתוך של פוליגונים קמורים}\label{ux5d7ux5d9ux5eaux5d5ux5da-ux5e9ux5dc-ux5e4ux5d5ux5dcux5d9ux5d2ux5d5ux5e0ux5d9ux5dd-ux5e7ux5deux5d5ux5e8ux5d9ux5dd}}

בחלק השלישי של יחידה 2 (המדבר על פעולות בוליאניות), ראינו שניתן לחשב את החיתוך של שני פוליגונים (לא בהכרח קמורים) בזמן O ( ( n + k ) log n ), כאשר k הוא מספר נקודות חיתוך, בעזרת האלגוריתם MapOverlay.

מהו המספר המקסימלי האפשרי של נקודות חיתוך בין צלעות של שני פוליגונים קמורים בעלי \(n\) קודקודים כל אחד? נסו לצייר שני פוליגונים קמורים עם מספר מקסימלי של נקודות חיתוך.

(פתרון)

המספר המקסימלי האפשרי של נקודות חיתוך בין שני פוליגונים קמורים \(C_1\) ו-\(C_2\) בעלי
\(n\) נקודות כל אחד, הוא
\(2 n\). הסיבה היא שכל צלע \(e\) של \(C_1\) יכולה להחתך עם לכל היותר שתי צלעות של \(C_2\): אם \(e\) היתה נחתכת עם יותר משתי צלעות של \(C_2\), אז \(C_2\) לא היה יכול להיות קמור.

הנה דוגמה למשפחה של זוגות פוליגונים קמורים \(C_1\) ו-\(C_2\) כך שכל צלע של \(C_1\) נחתכת עם בדיוק שתי צלעות של \(C_2\): אלו זוגות של פוליגונים משוכללים בעלי \(n\) צלעות המסובבים בזוית שונה שונה סביב המרכז.

אם נשתמש באלגוריתם MapOverlay עבור מציאת החיתוך בין פוליגונים קמורים, זמן הריצה יהיה \(O ( n \log n )\), כי כמו שראינו בשאלה למעלה, \(k \le 2 n\). לכן, לפי שיטת האב (Master Theorem), זמן הריצה הכולל עבור אלגוריתם IntersectHalfPlanes יהיה \(O ( n \log^2 n )\). האם בכל זאת ניתן לחשב את החיתוך באופן יעיל יותר עבור תחומים קמורים? התשובה היא כן! (זכרו שתמיד נשאף לזמן ריצה לינארי, או \(O ( n \log n )\)\ldots)

אלגוריתם MapOverlay משתמש בשיטת הישר הסורק, ולזמן הריצה שלו יש שני גורמים. הגורם הראשון הוא \(( n + k )\) -- מספר המאורעות. הגורם השני הוא \(\log n\) -- הזמן לטיפול במאורע, כלומר, עדכון הסטטוס (שיכול להכיל \(O ( n )\) קטעים), והוספת מאורע לתור המאורעות בכל פעם שמצאנו נקודת חיתוך. אך האם זהו המצב גם עבור פוליגונים קמורים?

למעשה, עבור פוליגונים קמורים יהיו לכל היותר 4 צלעות שחותכות את הישר הסורק בכל רגע נתון. נוכל לראות זאת אם נחלק כל פוליגון לשרשרת ימנית ושרשרת שמאלית (מהקודקד הגבוה ביותר לקודקוד הנמוך ביותר). כל שרשרת כזאת היא \(y\)-מונוטונית, ולכן חותכת את הישר הסורק (האופקי) פעם אחת בלבד.

עובדה זו מובילה לכך שהטיפול בכל מאורע יתבצע בזמן קבוע, וכבר לא יהיה לנו צורך במאורעות שהם נקודות חיתוך. באופן זה נקבל אלגוריתם למציאת חיתוך של פוליגונים קמורים עם זמן ריצה של \(O ( n )\) בלבד, ובכך נשפר את זמן הריצה עבור חיתוך חצאי מישורים ל-\(O ( n \log n )\).

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e9ux5e0ux5d9-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-4.2-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-7168.}{%
\subsubsection*{קראו את חלקו השני של סעיף 4.2 בספר הלימוד (עמודים 71--68).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e9ux5e0ux5d9-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-4.2-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-7168.}}
\addcontentsline{toc}{subsubsection}{קראו את חלקו השני של סעיף 4.2 בספר הלימוד (עמודים 71--68).}

\hypertarget{ux5eaux5dbux5e0ux5d5ux5df-ux5dcux5d9ux5e0ux5d0ux5e8ux5d9-ux5d1ux5deux5d9ux5e9ux5d5ux5e8}{%
\section{תכנון לינארי במישור}\label{ux5eaux5dbux5e0ux5d5ux5df-ux5dcux5d9ux5e0ux5d0ux5e8ux5d9-ux5d1ux5deux5d9ux5e9ux5d5ux5e8}}

\hypertarget{ux5deux5d4ux5d5-ux5eaux5dbux5e0ux5d5ux5df-ux5dcux5d9ux5e0ux5d0ux5e8ux5d9}{%
\subsection{מהו תכנון לינארי?}\label{ux5deux5d4ux5d5-ux5eaux5dbux5e0ux5d5ux5df-ux5dcux5d9ux5e0ux5d0ux5e8ux5d9}}

תכנון לינארי היא בעיית אופטימיזציה של ביטוי לינארי, תחת אוסף של אילוצים לינאריים. זוהי בעייה מרכזית בתחום של חקר ביצועים, שבו בעיות אופטימיזציה רבות ניתנות לתאור באמצעות תוכנית לינארית. הבעיה צברה פופולריות רבה משום שהיא שימושית בתחומים רבים נוספים, ולכן במשך השנים נעשו מאמצים רבים למציאת פתרונות יעילים ומהירים עבורה. בסרטון הבא נראה דוגמה לתוכנית כזאת, נזכיר חלק מהכלים הקיימים כיום לפתרון בעיות תכנון לינארי, ונדבר על הקשר בין תכנון לינארי במישור לבעיית החיתוך של חצאי מישורים.

\hypertarget{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-3}{%
\subsubsection*{צפו בסרטון הבא:}\label{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-3}}
\addcontentsline{toc}{subsubsection}{צפו בסרטון הבא:}

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e8ux5d0ux5e9ux5d5ux5df-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-4.3-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-7172.}{%
\subsubsection*{קראו את חלקו הראשון של סעיף 4.3 בספר הלימוד (עמודים 71--72).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e8ux5d0ux5e9ux5d5ux5df-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-4.3-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-7172.}}
\addcontentsline{toc}{subsubsection}{קראו את חלקו הראשון של סעיף 4.3 בספר הלימוד (עמודים 71--72).}

\hypertarget{ux5d0ux5dcux5d2ux5d5ux5e8ux5d9ux5eaux5dd-ux5d0ux5d9ux5e0ux5e7ux5e8ux5deux5e0ux5d8ux5dcux5d9}{%
\subsection{אלגוריתם אינקרמנטלי}\label{ux5d0ux5dcux5d2ux5d5ux5e8ux5d9ux5eaux5dd-ux5d0ux5d9ux5e0ux5e7ux5e8ux5deux5e0ux5d8ux5dcux5d9}}

בחלקו השני של סעיף 4.3 בספר הלימוד מתואר אלגוריתם אינקרמנטלי בשם 2DBoundedLP, לפתרון של תוכנית לינארית בשני מימדים. האלגוריתם פועל תחת ההנחה שהתוכנית הלינארית חסומה. לכן, בשלב הזה נניח כי ניתן למצוא ולהוסיף לתוכנית הלינארית שני חצאי מישורים \(m_1, m_2\), שיגרמו לכך שהתוכנית תהיה חסומה בכיוון \(\overrightarrow{c}\), אך לא ישנו את הפתרון האופטימלי במקרה שבו התוכנית חסומה. בהמשך נראה כיצד להימנע מהנחה זו ולקבוע מראש האם התוכנית חסומה או לא.

האלגוריתם האינקרמנטלי מתחיל מפתרון עבור \(C_0 = m_1 \cap m_2\), ואז מוסיף את יתר חצאי המישורים \(h_1, \dots, h_n\) לפי הסדר. בשלב ה-\(i\), האלגוריתם ימצא קודקוד v\_i שהוא הנקודה שממקסמת את פונקציית המטרה בחיתוך \(C_i = m_1 \cap m_2 \cap h_1 \cap h_2 \cap \dots \cap h_i\). הרעיון הוא שבכל שלב מצמצמים את התחום הפיזיבילי, ויש שתי אפשרויות עבור \(v_i\):

אם \(v_{i-1}\in h_i\) (כמו באיור הימני למטה), אז \(h_i\) לא שינה את הפתרון האופטימלי ולכן \(v_i = v_{i-1}\). אחרת, \(h_i\) גרם לכך ש-\(C_i\) כבר לא כולל את \(v_{i-1}\) (כמו באיור השמאלי למטה). בספר תראו הוכחה לכך שבמקרה זה, אם \(C_i\) לא ריק, אז \(v_i\) בהכרח נמצא על הישר \(\ell_i\) המגדיר את חצי המישור \(h_i\).

באופן די מאכזב, זמן הריצה המתקבל מאלגוריתם זה הוא \(O(n^2)\), מכיון שבמקרה השני נצטרך לחשב את החיתוך של \(\ell_i\) עם חצאי המישורים \(m_1, m_2, h_1, \dots, h_{i-1}\). לכן, במקרה הגרוע, זמן הריצה עבור השלב ה-\(i\) יהיה \(O(i)\).

כמה פעמים יתעדכן הפתרון? נסו לחשוב על המקרה הגרוע ביותר: כמה פעמים לכל היותר יכול לקרות המקרה השני, בו נצטרך לעדכן את \(v_i\) בזמן \(O(i)\)?

(התשובה נמצאת בפסקה האחרונה של סעיף 4.3 בספר הלימוד)

בהמשך נראה כיצד בחירה רנדומית של הסדר בו מוסיף האלגוריתם את חצאי המישורים, מובילה לתוחלת זמן ריצה לינארית.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e9ux5e0ux5d9-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-4.3-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-7376.}{%
\subsubsection*{קראו את חלקו השני של סעיף 4.3 בספר הלימוד (עמודים 73--76).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e9ux5e0ux5d9-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-4.3-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-7376.}}
\addcontentsline{toc}{subsubsection}{קראו את חלקו השני של סעיף 4.3 בספר הלימוד (עמודים 73--76).}

\hypertarget{ux5d0ux5dcux5d2ux5d5ux5e8ux5d9ux5eaux5dd-ux5e8ux5e0ux5d3ux5d5ux5deux5d9}{%
\subsection{אלגוריתם רנדומי}\label{ux5d0ux5dcux5d2ux5d5ux5e8ux5d9ux5eaux5dd-ux5e8ux5e0ux5d3ux5d5ux5deux5d9}}

כמו שהובטח בחלקים הקודמים, תכנון לינארי במישור אכן ניתן לפיתרון בזמן צפוי של \(O( n )\), על ידי האלגוריתם
2DRandomizedBoundedLP אותו נציג בחלק זה. זהו כמובן אלגוריתם רנדומי, והוא זהה כמעט לחלוטין לאלגוריתם האינקרמטלי שהוצג בסעיף הקודם: ההבדל היחידי הוא בשורה השנייה של האלגוריתם, שם מחשבים פרמוטציה אקראית של חצאי המישורים בעזרת פרוצדורה בשם RandomPermutation.

בסרטון הבא נראה כיצד שינוי זה, שנראה לכאורה כאילו אינו משפיע על האלגוריתם, מוביל לתופעה מעניינת ביותר: תוחלת זמן ריצה תהיה לינארית. כלומר, כאשר מגרילים את הסדר בו האלגוריתם האינקמנטלי בוחן את חצאי המישורים, מקבלים שבממוצע על פני כל הפרמוטציות האפשריות, זמן הריצה הוא \(O( n )\).

\hypertarget{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-4}{%
\subsubsection{צפו בסרטון הבא:}\label{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-4}}

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-4.3-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-6668.}{%
\subsubsection*{קראו את סעיף 4.3 בספר הלימוד (עמודים 66--68).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-4.3-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-6668.}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 4.3 בספר הלימוד (עמודים 66--68).}

\hypertarget{ux5eaux5d5ux5dbux5e0ux5d9ux5ea-ux5dcux5d9ux5e0ux5d0ux5e8ux5d9ux5ea-ux5e9ux5d0ux5d9ux5e0ux5d4-ux5d7ux5e1ux5d5ux5deux5d4}{%
\subsection{תוכנית לינארית שאינה חסומה}\label{ux5eaux5d5ux5dbux5e0ux5d9ux5ea-ux5dcux5d9ux5e0ux5d0ux5e8ux5d9ux5ea-ux5e9ux5d0ux5d9ux5e0ux5d4-ux5d7ux5e1ux5d5ux5deux5d4}}

בסעיפים הקודמים נמנענו מהטיפול במקרה בו התוכנית הלינארית אינה חסומה, על ידי הוספת שני אילוצים מלאכותיים, \(m_1,m_2\). בחלק זה נראה כיצד ניתן לבדוק האם תוכנית לינארית היא חסומה, ואם היא לא חסומה, נראה כיצד למצוא שני אילוצים \(h_1,h_2\) שישמשו אותנו לאתחול האלגוריתם במקום \(m_1,m_2\).

אם התוכנית הלינארית אינה חסומה, אז קיימת קרן \(\rho\) המוכלת כולה באיזור הפיזיבילי \(C\). הקרן הזו מוגדרת על ידי נקודה p וכיוון \(\overrightarrow{d}\). נשים לב שפונקציית המטרה מקבלת ערכים הולכים וגדלים לאורך הקרן rho אם ורק אם הזווית הקטנה בין הוקטור \(\overrightarrow{d}\) לוקטור המטרה \(\overrightarrow{c}\) קטנה מ-\(90 ^\circ\). בנוסף, לכל חצי מישור \(h\), הזוית בין \(\overrightarrow{d}\) לנורמל \(\overrightarrow{\mu}( h )\) של h (בכיוון הצד הפיזיבילי) היא לכל היותר . ניתן לראות דוגמה לכך בציור מטה. נוסף לכך, אוסף האילוצים עבורם \(\overrightarrow{\mu}( h )\) בדיוק מאונך ל-\(\overrightarrow{d}\) (\(h_1, h_5\) באיור), חייב להיות פיזיבילי.

שימו לב שהבעיה של מציאת הקרן \(\rho\) דומה לבעיית הייצור באמצעות תבניות שראינו בחלק הראשון של יחידה זו. מכיוון שכאן הבעיה מוגדרת בשני מימדים, נוכל לפתור אותה על ידי תכנון לינארי במימד אחד, בזמן \(O( n )\). בסעיף 4.5 של ספר תוכלו לקרוא תיאור מפורט של פתרון זה.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-4.4-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-7982.}{%
\subsubsection*{קראו את סעיף 4.4 בספר הלימוד (עמודים 79--82).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-4.4-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-7982.}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 4.4 בספר הלימוד (עמודים 79--82).}

\textbf{פתרון אלטרנטיבי}:

דרך אחרת למציאת הקרן \(\rho\), היא להתבונן בחצי המישור \(h_i\) עבורו הזווית הקטנה בין \(\overrightarrow{c}\) ל-\(\overrightarrow{\mu}( h_i )\) היא הגדולה ביותר.

~\\
\hspace*{0.333em}

החיתוך בין הישר לבין חצי מישור אחר \(h_j\) הוא קרן \(\rho\) על . אם לכל \(j \neq i\) הזוית הקטנה בין הקרן \(\rho\) שמוגדרת על ידי \(\ell_1 \cap h_j\) לבין \(\overrightarrow{c}\) קטנה או שווה ל-, אז הקרן שראשיתה בנקודה הקיצונית ביותר בכיוון \(\overrightarrow{c}\) היא העדות לכך ש-C אינו חסום ביחס ל-\(\overrightarrow{c}\).

אחרת, אם עבור \(h_j\) כלשהו הזוית הקטנה בין \(\rho\) ל-\(\overrightarrow{c}\) גדולה מ-, אז חצאי המישורים \(h_i\) ו-\(h_j\) הם ההוכחה לכך ש-\(C\) חסום ביחס ל-\(\overrightarrow{c}\). הסיבה לכך היא שהזווית בין \(\overrightarrow{c}\) ל-\(\overrightarrow{\mu}( h_j )\) קטנה יותר מהזווית בין \(\overrightarrow{c}\) ל-\(\overrightarrow{\mu}( h_i )\), ולכן הזוית בין \(h_j\) ל-\(\overrightarrow{c}\) גדולה מ-\(90^\circ\).
~

\hypertarget{orthogonal-range-seach}{%
\chapter{חיפוש בתחומים אורתוגונלים}\label{orthogonal-range-seach}}

\hypertarget{preface}{%
\section{הקדמה}\label{preface}}

\hypertarget{data-bases}{%
\subsection{חיפוש במסדי נתונים}\label{data-bases}}

מסדי נתונים המאחסנים רשומות בצורה של טבלה הם כלי מרכזי לארגון מידע בישומים רבים. כפי שראינו בהקדמה לקורס, למרות שבמבט ראשון לא נראה שיש קשר בין מסדי נתונים כאלו לגאומטריה, הקשר הזה אכן קיים עבור סוגים מסויימים של שאילתות.

הייצוג הגאומטרי של מסד הנתונים יהיה באמצעות אוסף של נקודות במרחב ה-\(d\) מימדי: כל רשומה תיוצג באמצעות נקודה במרחב, כאשר כל שדה של הרשומה מתאים לקואורדינטה. עבור שאילתה המבקשת את אוסף הרשומות הנמצאות בתחום מסויים של ערכים (בשדה אחד או יותר), הייצוג הגאומטרי יהיה תחום אורתוגונלי \(R\), כלומר, תיבה \(d\)-מימדית מקבילה לצירים. במישור זהו מלבן שצלעותיו מקבילות לצירים, ובשלושה מימדים זוהי קוביה שפאותיה מקבילות לצירים.

בפרק זה נציג שני מבני נתונים לאחסון אוסף \(P\) של נקודות במרחב ה-\(d\) מימדי, כך שנוכל לענות ביעילות על שאילתות מהסוג הבא: בהינתן תחום אורתוגונלי \(R\), אילו מהנקודות של \(P\) נמצאות בתוך \(R\)?

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d4ux5d4ux5e7ux5d3ux5deux5d4-ux5dcux5e4ux5e8ux5e7-5-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-9596.}{%
\subsubsection*{קראו את ההקדמה לפרק 5 בספר הלימוד (עמודים 95־96).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d4ux5d4ux5e7ux5d3ux5deux5d4-ux5dcux5e4ux5e8ux5e7-5-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-9596.}}
\addcontentsline{toc}{subsubsection}{קראו את ההקדמה לפרק 5 בספר הלימוד (עמודים 95־96).}

\hypertarget{on-the-line}{%
\subsection{חיפוש בתחומים על הישר}\label{on-the-line}}

בעיות רבות בגאומטריה חישובית נעשות פשוטות הרבה יותר כאשר הן נתונות במימד אחד, ובמחקר התאורטי מופיעים לעיתים קרובות פתרונות במימד אחד לבעיות מורכבות, כצעד מקדים לפתרונות במימדים גבוהים יותר. לכן, לפני שניגש לפתרון הבעיה של חיפוש בתחומים בשני מימדים או יותר, ננסה קודם להבין כיצד ניתן לפתור אותה עבור אוסף P של נקודות ממימד אחד, כלומר, אוסף של נקודות שכולן על ישר אחד. שימו לב שהשאילתה על הישר היא פשוט טווח של ערכים, R equals left square bracket x comma x' right square bracket.

אפשרות אחת לפתרון היא למיין את נקודות P ולשמור אותן במערך. בהינתן טווח left square bracket x comma x' right square bracket, נמצא בעזרת חיפוש בינארי את הנקודות הראשונה במערך שגדולה או שווה ל-x, ואז נעבור על תאי המערך לפי הסדר החל מנקודה זו, ונדווח על נקודות כל עוד הן קטנות או שוות ל-x'. זמן השאילתה יהיה O( log n plus k) כאשר k הוא מספר הנקודות בפלט. זמן העיבוד המקדים הוא O( n log n) וסיבוכיות המקום היא O( n). לפתרון המשתמש במערך יש שני חסרונות: הוא לא דינאמי (כלומר, לא ניתן לבצע הוספה או מחיקה של נקודות), ולא ניתן להכליל אותו למימדים גבוהים. לכן, פרק 5.1 של ספר הלימוד מתאר פתרון המשתמש בעץ חיפוש בינארי, שבו הנקודות מופיעות בעלים. כל קודקוד פנימי מכיל את הערך המקסימלי של עלה המופיע בתת העץ השמאלי שלו. בהינתן עץ חיפוש T וטווח left square bracket x comma x ' right square bracket, אלגוריתם השאילתה 1DRangeQuery מוצא את הקודקוד בו המסלולים מהשורש ל-x ו-x ' מתפצלים, ואז מחזיר את כל הנקודות בעלים שנמצאים מימין להמשך המסלול ל-bold italic x, ואת הנקודות בעלים שנמצאים משמאל להמשך המסלול ל-bold italic x bold'. אלו בדיוק הערכים בעץ הנמצאים בין x ' ל-x.

בהמשך של יחידה זו, נראה שתי דרכים שונות להכללת פתרון זה עבור מימדים גבוהים.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-5.1-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-9699.}{%
\subsubsection*{קראו את סעיף 5.1 בספר הלימוד (עמודים 96--99).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-5.1-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-9699.}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 5.1 בספר הלימוד (עמודים 96--99).}

\hypertarget{in-the-plane}{%
\section{חיפוש בתחומים במישור}\label{in-the-plane}}

\hypertarget{kd-trees}{%
\subsection{עצי-kd}\label{kd-trees}}

עץ KDמבנה הנתונים הראשון שנראה עבור חיפוש בתחומים בשני מימדים, נקרא עץ-kd. העץ הזה הוא הכללה של עץ החיפוש שראינו עבור נקודות במימד אחד, שבו משנים בכל רמה של העץ את הקואורדינטה שלפיה בוחרים את החציון.

\hypertarget{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-5}{%
\subsubsection*{צפו בסרטון הבא:}\label{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-5}}
\addcontentsline{toc}{subsubsection}{צפו בסרטון הבא:}

ניתן לבנות עץ-kd עבור אוסף של n נקודות בזמן O( n log n). סיבוכיות המקום שלו היא O( n), וזמן השאילתה הוא \(O(\sqrt{n}+ k)\), כאשרk הוא גודל הפלט, כלומר מספר הנקודות הנמצאות בתחום הנתון. בסעיף 5.2 מתואר האלגוריתם BuildKdTree שבונה את העץ, ואלגוריתם השאילתה SearchKdTree. קראו בעיון את ניתוח זמן הבניה, סיבוכיות המקום, וזמן השאילתה של עץ ה-kd.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-5.2-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-99105.}{%
\subsubsection*{קראו את סעיף 5.2 בספר (עמודים 99--105).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-5.2-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-99105.}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 5.2 בספר (עמודים 99--105).}

זמן הריצה של האלגוריתם הראשון שמתואר בסרטון ומשתמש בשיטת הישר הסורק, הואהתבוננו בקבוצת הנקודות הבאה, והשלימו את עץ ה-kd.

(פתרון)

(TODO)

התבוננו בחלוקה שנוצרה עבור עץ ה-kd והתחום המלבני שבאיור, וענו על השאלות הבאות:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  אילו מהנקודות יבדקו (אך לא בהכרח ידווחו) בשורה 2 של אלגוריתם SearchKdTree?
\item
  אלו מהנקודות ידווחו על ידי הפרוצדורה ReportSubtree?
\end{enumerate}

(פתרון)

(TODO)

\hypertarget{ux5eaux5d7ux5d5ux5deux5d9ux5dd-ux5e9ux5d0ux5d9ux5e0ux5dd-ux5deux5dcux5d1ux5e0ux5d9ux5d9ux5dd.}{%
\subsubsection*{תחומים שאינם מלבניים.}\label{ux5eaux5d7ux5d5ux5deux5d9ux5dd-ux5e9ux5d0ux5d9ux5e0ux5dd-ux5deux5dcux5d1ux5e0ux5d9ux5d9ux5dd.}}
\addcontentsline{toc}{subsubsection}{תחומים שאינם מלבניים.}

שימו לב שניתן להכליל את אלגוריתם השאילתה גם עבור תחומים שאינם מלבניים. על מנת שהאלגוריתם יהיה יעיל עבור תחום R שאינו מלבני, התחום חייב להיות מתואר בצורה שתאפשר את שתי הפעולות הבאות בזמן קבוע:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  לבדוק האם R מכיל נקודה נתונה.
\item
  לבדוק האם R מכיל או נחתך עם תחום מלבני המתאים לצומת כלשהו.
\end{enumerate}

אם R הוא מצולע קמור בעל c צלעות, כיצד נוכל לבצע את הפעולות האלו? ומה יהיה זמן הריצה? מה אם R הוא עיגול הנתון על ידי המרכז והרדיוס שלו?

\hypertarget{range-trees}{%
\subsection{עצי תחומים (Range Trees)}\label{range-trees}}

בחלק זה נראה מבנה נתונים אחר לחיפוש בתחומים במישור הנקרא עץ תחומים, range tree. גם הוא הכללה של עץ החיפוש שראינו עבור נקודות על הישר, אך באופן שונה: כאן כל קודקוד פנימי בעץ הממיין את הנקודות לפי קואורדינטת ה-x, יכיל מצביע לעץ נוסף הממיין את העלים בתת העץ שלו לפי קואורדינטת ה-y.

\hypertarget{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-6}{%
\subsubsection*{צפו בסרטון הבא:}\label{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-6}}
\addcontentsline{toc}{subsubsection}{צפו בסרטון הבא:}

(TODO)

מבחינת זמן השאילתה, במקרה הגרוע עץ תחומים יעיל הרבה יותר מעץ-kd - זמן השאילתה שלו הוא \(O( log^2 n + k)\) בלבד, לעומת \(O( \sqrt{n}+k)\) בעצי-kd. השיפור הזה מאלץ אותנו לשלם מעט בסיבוכיות המקום -- \(O( n log n)\) לעומת \(O( n)\). בסעיף 5.3 של ספר הלימוד מתואר האלגוריתם Build2DRangeTree שבונה את העץ, ואלגוריתם השאילתה 2DRangeQuery. קראו בעיון את ניתוח זמן הבניה, סיבוכיות המקום, וזמן השאילתה של עץ תחומים.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-5.3-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-105109.}{%
\subsubsection*{קראו את סעיף 5.3 בספר (עמודים 105--109).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-5.3-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-105109.}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 5.3 בספר (עמודים 105--109).}

\hypertarget{ux5e9ux5d9ux5e4ux5d5ux5e8-ux5d6ux5deux5df-ux5d4ux5e9ux5d0ux5d9ux5dcux5eaux5d4.}{%
\subsubsection*{שיפור זמן השאילתה.}\label{ux5e9ux5d9ux5e4ux5d5ux5e8-ux5d6ux5deux5df-ux5d4ux5e9ux5d0ux5d9ux5dcux5eaux5d4.}}
\addcontentsline{toc}{subsubsection}{שיפור זמן השאילתה.}

ניתן לשפר את זמן השאילתה של עץ התחומים בפקטור של log n, בעזרת שיטה הנקראת Fractional Cascading . זוהי שיטה מתקדמת שאינה חלק מחומר הקורס, והיא מתוארת בפרק 5.6 של הספר.

\hypertarget{extensions}{%
\section{הרחבות}\label{extensions}}

\hypertarget{higher-dim}{%
\subsection{מימדים גבוהים}\label{higher-dim}}

בשתי הפסקאות האחרונות של סעיף 5.2 בספר הלימוד מתוארת בקצרה הבנייה של עצי-kd במימד \(d>2\). עבור \(d\) קבוע, זמן הבניה נשאר \(O( n \log n)\) וסיבוכיות הזיכרון נשארת \(O( n)\). זמן השאילתה לעומת זאת הוא \(O( n^{1-\frac{1}{d}}+k)\), והוא מתקרב ל-\(O( n)\) ככל ש-\(d\) גדל. בפרק 5.4 מתוארת הרחבה של עצי תחומים למימד \(d>2\). כאן זמן העיבוד המקדים וסיבוכיות המקום הם \(O( n \log^{d-1} n)\), וזמן השאילתה הוא \(O( \log^d n +k)\).

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-5.4-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-109110.}{%
\subsubsection*{קראו את סעיף 5.4 בספר (עמודים 109--110).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-5.4-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-109110.}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 5.4 בספר (עמודים 109--110).}

\hypertarget{general-pos}{%
\subsection{אוסף נקודות כללי}\label{general-pos}}

בפרקים 5.1־5.3 של ספר הלימוד אנו מניחים שאין באוסף הנתון שתי נקודות בעלות אותה קואורדינטת \(x\) או אותה קואורדינטת \(y\). זוהי הנחה שאינה מתיישבת עם המציאות, מכיוון ששדות בטבלה עשויים לייצג ערכים בעלי מספר קטן של אפשרויות, כמו גיל או תאריך, ולכן סביר שיהיו המון נקודות בעלות ערכים זהים באותה קואורדינטה. למרבה המזל, הכללת מבני הנתונים שראינו עבור קלט כללי היא לא משימה קשה, וניתן לעשות זאת על ידי בחירה של סדר לקסיגורפי מסוים על הנקודות. תוכלו לקרוא על כך בפרק 5.5 של ספר הלימוד.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-5.5-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-110111.}{%
\subsubsection*{קראו את סעיף 5.5 בספר (עמודים 110--111).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-5.5-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-110111.}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 5.5 בספר (עמודים 110--111).}

\hypertarget{point-location}{%
\chapter{מיקום נקודה ומפה טרפזית}\label{point-location}}

\hypertarget{preface}{%
\section{הקדמה}\label{preface}}

\hypertarget{point-on-map}{%
\subsection{מיקום נקודה במפה}\label{point-on-map}}

מפה המתארת חלוקה למחוזות, כמו מפת ישראל המופיעה כאן משמאל, היא בעצם גרף מישורי המתואר באמצעות צלעות, פאות, וקודקודים.
כל מחוז או איזור במפה מתאים לפאה של הגרף.
ביחידה הזו נעסוק בבעיה הבסיסית הבאה: בהינתן הקואורדינטות של נקודה כלשהי על המפה, לאיזה מחוז היא שייכת?

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d4ux5d4ux5e7ux5d3ux5deux5d4-ux5dcux5e4ux5e8ux5e7-6-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-121122.}{%
\subsubsection*{קראו את ההקדמה לפרק 6 בספר הלימוד (עמודים 121־122).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d4ux5d4ux5e7ux5d3ux5deux5d4-ux5dcux5e4ux5e8ux5e7-6-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-121122.}}
\addcontentsline{toc}{subsubsection}{קראו את ההקדמה לפרק 6 בספר הלימוד (עמודים 121־122).}

\hypertarget{trapezoidal-map}{%
\section{מפה טרפזית}\label{trapezoidal-map}}

\hypertarget{naive-sol}{%
\subsection{פתרון נאיבי: חלוקה לרצועות}\label{naive-sol}}

תהי \(\mathcal{S}\) מפה מישורית, כפי שהגדרנו ביחידה 2 של הקורס: \(\mathcal{S}\) היא שיכון של גרף מישורי במישור, כך שכל הצלעות שלו הן קטעים ישרים.
נרצה לבנות מבנה נתונים שיענה על שאילתות מהסוג הבא: בהינתן נקודה \(q\) במישור, מצא את הפאה בה \(q\) נמצאת.

שימו לב שכדי למצוא את הפאה בה \(q\) נמצאת, מספיק לבדוק (למשל) איזו צלע של \(\mathcal{S}\) הנקודה \(q\) ``רואה'' מעליה.
לכן, בחלק הראשון של סעיף 6.1 בספר הלימוד מתואר פתרון נאיבי ופשוט לבעיה, על ידי חלוקה של המפה לרצועות (slabs): נעביר ישר אנכי דרך כל אחד מהקודקודים של \(\mathcal{S}\). האיזור שנמצא בין שני ישרים עוקבים כאלו הוא רצועה אנכית.
בהינתן שמספר הקודקודים במפה \(\mathcal{S}\) הוא n, ניתן למצוא את הרצועה שבה נמצאת נקודה נתונה \(q\) בזמן \(O (\log n )\) על ידי חיפוש בינארי.
מכיוון שאין קודקודים של \(\mathcal{S}\) בתוך הרצועה, נוכל למצוא את הצלע שהנקודה \(q\) ``רואה'' מעליה על ידי חיפוש בינארי על פני הקטעים שחותכים את הרצועה, כלומר שוב \(O (\log n )\).

בדרך זו, זמן השאילתה שנקבל הוא \(O (\log n )\), אך מהו גודל המבנה וזמן העיבוד המקדים?
באיור למטה ניתן לראות דוגמה למקרה בו גודל המבנה יהיה \(\Theta ( n^2 )\) (מדוע?).

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e8ux5d0ux5e9ux5d5ux5df-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-6.1-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-122124.}{%
\subsubsection*{קראו את חלקו הראשון של סעיף 6.1 בספר הלימוד (עמודים 122--124).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e8ux5d0ux5e9ux5d5ux5df-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-6.1-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-122124.}}
\addcontentsline{toc}{subsubsection}{קראו את חלקו הראשון של סעיף 6.1 בספר הלימוד (עמודים 122--124).}

\hypertarget{ux5e4ux5d9ux5e8ux5d5ux5e7-ux5dcux5d8ux5e8ux5e4ux5d6ux5d9ux5dd}{%
\subsection{פירוק לטרפזים}\label{ux5e4ux5d9ux5e8ux5d5ux5e7-ux5dcux5d8ux5e8ux5e4ux5d6ux5d9ux5dd}}

שימו לב שהחלוקה לרצועות שראינו בעמוד הקודם יוצרת מפה מישורית \(\mathcal{S'}\) שבה כל פאה היא טרפז או משולש (או פאה אינסופית דמויית טרפז/משולש).
המפה \(\mathcal{S'}\) היא עידון (refinement) של המפה המקורית \(\mathcal{S}\), כלומר, כל פאה של \(\mathcal{S'}\) מוכלת לחלוטין בפאה של \(\mathcal{S}\), ולכן אם מצאנו שנקודת השאילתה נמצאת בפאה מסויימת של \(\mathcal{S'}\), נוכל לדעת לאיזו פאה של \(\mathcal{S}\) היא שייכת.
העידון בעזרת חלוקה לרצועות מוביל למבנה נתונים בגודל ריבועי (במקרה הגרוע), ולכן אינו מעשי.
בחלק זה נראה עידון אחר שסיבוכיות הזיכרון שלו לא תהיה גדולה בהרבה מזו של \(\mathcal{S}\), ועדיין יאפשר לנו לענות על שאילתות מיקום נקודה בקלות יחסית.

\hypertarget{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-7}{%
\subsubsection*{צפו בסרטון הבא:}\label{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-7}}
\addcontentsline{toc}{subsubsection}{צפו בסרטון הבא:}

(TBD)

מיהי ה-\(leftp\) של כל אחד מהטרפזים המסומנים באיור?

(פתרון)

(TODO)

\hypertarget{ux5d4ux5e0ux5d7ux5ea-ux5deux5e6ux5d1-ux5dbux5dcux5dcux5d9.}{%
\subsubsection*{הנחת מצב כללי.}\label{ux5d4ux5e0ux5d7ux5ea-ux5deux5e6ux5d1-ux5dbux5dcux5dcux5d9.}}
\addcontentsline{toc}{subsubsection}{הנחת מצב כללי.}

בשיטת הפירוק לטרפזים אנחנו מניחים שבאוסף הקטעים הנתון אין שתי נקודות קצה בעלות אותה קואורדינטת \(x\).
הנחה זו אינה ריאליסטית, אך כפי שכבר ראינו בעבר, קיימות מספר שיטות המאפשרות לנו לטפל במצב לא כללי - למשל על ידי סיבוב המישור, או קביעת סדר לקסיקוגרפי.
הדיון בפתרונות אלו עבור המבנה של מפת טרפזים מופיע בפרק 6.3 בספר הלימוד.

במצב לא כללי, כמה טרפזים שכנים יש (לכל היותר) לטרפז במפה הטרפזית?

(פתרון)

\(\Theta(n)\)

\hypertarget{ux5dcux5d7ux5d6ux5e8ux5d4-ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e9ux5e0ux5d9-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-6.1-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-124128.}{%
\subsubsection*{לחזרה: קראו את חלקו השני של סעיף 6.1 בספר (עמודים 124--128).}\label{ux5dcux5d7ux5d6ux5e8ux5d4-ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e9ux5e0ux5d9-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-6.1-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-124128.}}
\addcontentsline{toc}{subsubsection}{לחזרה: קראו את חלקו השני של סעיף 6.1 בספר (עמודים 124--128).}

\hypertarget{point-location-queries}{%
\section{שאילתות מיקום נקודה}\label{point-location-queries}}

\hypertarget{the-data-structure}{%
\subsection{מבנה הנתונים}\label{the-data-structure}}

יהי \(\mathcal{S}\) אוסף של \(n\) קטעים במצב כללי שאינם נחתכים.

ניתן לבנות את המפה הטרפזית \(\mathcal{T}(\mathcal{S})\) בקלות יחסית על ידי שימוש בשיטת הישר הסורק (חישבו, כיצד?).
הבעיה היא, שבשיטה זו לא נוכל לבנות מבנה נתונים התומך בשאילתות מיקום נקודה, שהוא המטרה המרכזית שלנו ביחידה זו.
איך יראה מבנה נתונים כזה?

בחלק זה נתאר את מבנה החיפוש \(\mathcal{D}\) שיאפשר לנו לבצע שאילתות מיקום נקודה במפה הטרפזית \(\mathcal{D}\).
בהמשך, נראה אלגוריתם אינקרמטלי-רנדומי שבונה את המפה הטרפזית \(\mathcal{T}(\mathcal{S})\) ומבנה הנתונים \(\mathcal{D}\) גם יחד.

מבנה הנתונים \(\mathcal{D}\) יהיה גרף מכוון חסר מעגלים (DAG), עם שלושה סוגים של צמתים:

\begin{itemize}
\tightlist
\item
  צומת (פנימי) x - מתאים לנקודת קצה של קטע מ-\(\mathcal{S}\) (מסומן בעיגול לבן).
\item
  צומת (פנימי) y - מתאים לקטע מ-\(\mathcal{S}\) (מסומן בעיגול אפור).
\item
  עלה - מתאים לטרפז במפה \(\mathcal{T}(\mathcal{S})\) (מסומן בריבוע).
\end{itemize}

בנוסף, לגרף יש שורש יחיד, ובדיוק עלה אחד לכל טרפז במפה \(\mathcal{D}\).
באיור למשל, לעלה של טרפז C יש מצביעים משני קודקודים פנימיים.

הרעיון בבנייה זו דומה לעצי-kd שראינו ביחידה 5: לכל צומת פנימי, ההסתעפות ימינה או שמאלה תלויה בתשובה לשאלה המתאימה לסוג הצומת.

בהינתן נקודת שאילתה q, נתחיל את החיפוש מהשורש עד שנגיע לעלה:

\begin{itemize}
\tightlist
\item
  אם הגענו לצומת-\(x\) המתאים לנקודת קצה \(p\), נשאל: ``האם \(q\) מימין או משמאל לישר האנכי שעובר דרךp?''. אם התשובה היא ``מימין'' - נמשיך ימינה, אחרת שמאלה.
\item
  אם הגענו לצומת-\(y\) המתאים לקטע \(s\), נשאל: ``האם \(q\) מעל או מתחת לקטע \(s\)?''. אם התשובה היא ``מתחת'' - נמשיך ימינה, אחרת שמאלה. שימו לב שכדי שהשאלה הזו תהיה הגיונית, נצטרך להבטיח שבשלב זה הישר האנכי שעובר דרך \(q\) חותך את \(s\).
\end{itemize}

כשנגיע לעלה, נבדוק האם הטרפז המתאים לו מכיל אתq.

בדקו את עצמכם!
ענו על השאלות הבאות.
נתון מבנה החיפוש הבא.

ידוע שנקודת שאילתה נמצאת:

\begin{itemize}
\tightlist
\item
  מימין לישר האנכי העובר בנקודה \(p_1\).
\item
  משמאל לישר האנכי העובר בנקודה \(q_1\).
\item
  מתחת לקטע \(s_1\).
\end{itemize}

באילו מהטרפזים יתכן שהנקודה נמצאת?

אם בנוסף ידוע שהנקודה נמצאת:

\begin{itemize}
\tightlist
\item
  משמאל לישר האנכי העובר בנקודה \(q_2\).
\item
  מעל לקטע \(s_2\).
\end{itemize}

באילו מהטרפזים יתכן שהנקודה נמצאת?

(פתרון)

TBD

\hypertarget{rand-inc-alg}{%
\subsection{אלגוריתם אינקרמנטלי רנדומי}\label{rand-inc-alg}}

בחלק זה נתאר אלגוריתם אינקרמנטלי לבניית מבנה החיפוש \(\mathcal{D}\) והמפה הטרפזית \(\mathcal{T}(\mathcal{S})\) גם יחד.
האלגוריתם מוסיף את הקטעים מהאוסף \(\mathcal{S}\) אחד אחרי השני בסדר רנדומי, ובכל פעם מעדכן את מבנה החיפוש והמפה בהתאם לקטע החדש שנוסף.

הסיבה לכך שנבחר סדר רנדומי על הקטעים היא שבאופן זה נוכל לצפות לזמני ריצה וסיבוכיות מקום יעילים, בדומה לאלגוריתם האינקרמנטלי-רנדומי לתכנון לינארי במישור שראינו ביחידה 4 של הקורס.
נדון בכך בעמוד הבא של חלק זה.

\hypertarget{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-8}{%
\subsubsection*{צפו בסרטון הבא:}\label{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0-8}}
\addcontentsline{toc}{subsubsection}{צפו בסרטון הבא:}

(TBD)

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e8ux5d0ux5e9ux5d5ux5df-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-6.2-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-128133.}{%
\subsubsection*{קראו את חלקו הראשון של סעיף 6.2 בספר (עמודים 128--133).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e8ux5d0ux5e9ux5d5ux5df-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-6.2-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-128133.}}
\addcontentsline{toc}{subsubsection}{קראו את חלקו הראשון של סעיף 6.2 בספר (עמודים 128--133).}

התבוננו באיור הבא:

מי הם הטרפזים שהאלגוריתם ימצא ויעדכן כאשר נוסיף את s\_i?

(פתרון)

התבוננו באיור הבא, והשלימו את מבנה החיפוש.

(פתרון)

\hypertarget{alg-analysis}{%
\subsection{ניתוח האלגוריתם}\label{alg-analysis}}

הסדר בו האלגוריתם TrapezoidalMap מוסיף את הקטעים משפיע מאוד על גודל מבנה החיפוש \(\mathcal{D}\) ועל זמן השאילתה.
למעשה, יתכן סידור שבו האלגוריתם ירוץ בזמן ריבועי, סיבוכיות הזיכרון של \(\mathcal{D}\) תהיה ריבועית, וזמן השאילתה יהיה לינארי.
לכן, בדומה לאלגוריתם האינקרמנטלי-רנדומי לתכנון לינארי במישור שראינו ביחידה 4 של הקורס, גם כאן האלגוריתם מגריל את סדר הוספת הקטעים מראש, ונוכל להראות שבתוחלת יתקבל מבנה חיפוש עם סיבוכיות זיכרון לינארית, וזמן שאילתה צפוי \(O (\log n )\).

מהו המקרה הגרוע ביותר?
נסו לתאר דוגמה לאוסף של \(n\) קטעים וסידור שלהם, כך שהאלגוריתם האינקרמנטלי (הלא רנדומי) ירוץ בזמן \(O ( n^2 )\).

\hypertarget{ux5e8ux5e2ux5d9ux5d5ux5df-ux5d4ux5d4ux5d5ux5dbux5d7ux5d4-ux5d6ux5deux5df-ux5d4ux5e9ux5d0ux5d9ux5dcux5eaux5d4.}{%
\subsubsection*{רעיון ההוכחה (זמן השאילתה).}\label{ux5e8ux5e2ux5d9ux5d5ux5df-ux5d4ux5d4ux5d5ux5dbux5d7ux5d4-ux5d6ux5deux5df-ux5d4ux5e9ux5d0ux5d9ux5dcux5eaux5d4.}}
\addcontentsline{toc}{subsubsection}{רעיון ההוכחה (זמן השאילתה).}

תהי \(q\) נקודת שאילתה.
נרצה להעריך את תוחלת אורך המסלול שנעבור במבנה \(\mathcal{D}\) כאשר נחפש את הטרפז שמכיל את \(q\) (מספר הצמתים מהשורש לטרפז).
לשם כך, ננסה להבין כיצד משתנה המסלול במהלך ריצת אלגוריתם הבנייה של \(\mathcal{D}\).

למשל, ניתן להראות שבכל פעם שקטע חדש נוסף למבנה, אורך המסלול יגדל בלכל היותר 3 צמתים.
לפיכך ניתן לומר שאורך המסלול הוא לכל היותר .
זהו חסם עבור המקרה הגרוע, אך אנו מעוניינים במקרה הממוצע (על פני כל \(n!\) הסידורים האפשריים), ולכן ננסה לחשב את ממוצע מספר הצמתים שנוספו למסלול בכל איטרציה של האלגוריתם.

נסמן ב-\(X_i\) (עבור \(1 \le i \le n\)) את מספר הצמתים על המסלול שנוספו באיטרציה ה-\(i\) (כלומר, לאחר הוספת הקטע \(s_i\)).
כלומר, \(X_i\) הוא משתנה מקרי התלוי בסדר הוספת הקטעים, ולכן תוחלת אורך המסלול אל הטרפז המכיל את \(q\) היא \(E[ \sum_{i=1}^{n} X_i ]\) ומלינאריות התוחלת \(\sum_{i=1}^{n} E[X_i]\).

מכיוון שבכל איטרציה נוספים לכל היותר 3 צמתים למסלול, מתקיים \(X_i \le 3\).
לכן, אם נסמן ב-\(P_i\) את ההסתברות לכך שקיים צומת במסלול שנוצר באיטרציה ה-\(i\), נקבל \(E[ X_i ] \le 3 P_i\).

האבחנה המרכזית בהוכחה היא שבאינטרציה ה-\(i\) נוסף קודקוד למסלול שלנו רק אם הטרפז שמכיל את \(q\) בדיוק לפני הוספת \(s_i\) שונה מהטרפז המכיל את \(q\) מיד לאחר הוספת \(s_i\).
לכן, בדומה להוכחה שראינו ביחידה 4, נוכל לנתח את ההסתברות לכך שהטרפז המכיל את \(q\) משתנה בין האיטרציה ה-\(i - 1\) לאיטרציה ה-\(i\) בשיטת הניתוח לאחור (backward analysis).
כלומר, נסתכל על המפה שהתקבלה מיד לאחר הוספת \(s_i\), ונשאל מה ההסתברות לכך שהטרפז \(\Delta\) המכיל את \(q\) במפה זו יעלם אם נוציא את \(s_i\).
שימו לב שהטרפז \(\Delta\) יעלם אם ורק אם אחד מהשדות המגדירים אותו (\(top(\Delta)\) , \(bottom(\Delta)\) , \(leftp(\Delta)\) , \(rightp(\Delta)\)) יעלם.
ההסתברות לכך ש-\(s_i\) הוא הקטע שמגדיר את \(top(\Delta)\) למשל, היא 1 over i, ובאופן דומה ניתן לחשב זאת עבור \(bottom(\Delta)\), \(leftp(\Delta)\) , \(rightp(\Delta)\).
לכן, נקבל \(P_i \le \frac{4}{i}\), ונוכל לחשב שתוחלת אורך המסלול היא \(O (\log n )\).

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e9ux5e0ux5d9-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-6.2-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-133137.}{%
\subsubsection*{קראו את חלקו השני של סעיף 6.2 בספר (עמודים 133--137).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d7ux5dcux5e7ux5d5-ux5d4ux5e9ux5e0ux5d9-ux5e9ux5dc-ux5e1ux5e2ux5d9ux5e3-6.2-ux5d1ux5e1ux5e4ux5e8-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-133137.}}
\addcontentsline{toc}{subsubsection}{קראו את חלקו השני של סעיף 6.2 בספר (עמודים 133--137).}

\hypertarget{ux5d3ux5d9ux5d0ux5d2ux5e8ux5deux5ea-ux5d5ux5d5ux5e8ux5d5ux5e0ux5d5ux5d9}{%
\chapter{דיאגרמת וורונוי}\label{ux5d3ux5d9ux5d0ux5d2ux5e8ux5deux5ea-ux5d5ux5d5ux5e8ux5d5ux5e0ux5d5ux5d9}}

\hypertarget{ux5d4ux5e7ux5d3ux5deux5d4-1}{%
\section{הקדמה}\label{ux5d4ux5e7ux5d3ux5deux5d4-1}}

\hypertarget{ux5d1ux5e2ux5d9ux5d9ux5ea-ux5d4ux5e9ux5dbux5df-ux5d4ux5e7ux5e8ux5d5ux5d1-ux5d1ux5d9ux5d5ux5eaux5e8-ux5d0ux5d5-ux5d1ux5e2ux5d9ux5d9ux5ea-ux5deux5d9ux5e7ux5d5ux5dd-ux5d4ux5e1ux5e0ux5d9ux5e4ux5d9ux5dd}{%
\subsection{בעיית השכן הקרוב ביותר (או: בעיית מיקום הסניפים)}\label{ux5d1ux5e2ux5d9ux5d9ux5ea-ux5d4ux5e9ux5dbux5df-ux5d4ux5e7ux5e8ux5d5ux5d1-ux5d1ux5d9ux5d5ux5eaux5e8-ux5d0ux5d5-ux5d1ux5e2ux5d9ux5d9ux5ea-ux5deux5d9ux5e7ux5d5ux5dd-ux5d4ux5e1ux5e0ux5d9ux5e4ux5d9ux5dd}}

נתון אוסף של מיקומי סניפים (נקודות במישור), ונניח שהלקוחות בוחרים להגיע לסניף הקרוב ביותר אליהם (לפי מרחק אוקלידי). לאיזה סניף יגיע כל לקוח? מהו הסניף הרווחי ביותר? היכן כדאי לנו למקם סניף נוסף כך שיהיה רווחי? דיאגרמת וורונוי (Voronoi diagram) היא מבנה גאומטרי בסיסי וחשוב ביותר, בעזרתו נוכל לענות על שאלות אלו, ועוד. זוהי בעצם חלוקה של המישור לתאים, תא אחד לכל סניף (נקודה במישור), כך שכל תא מכיל בדיוק את אוסף הנקודות במישור הקרובות לסניף שלו יותר מאשר לכל אחד מהסניפים האחרים.

\textbf{מעניין לדעת}: לדיאגרמת וורונוי יש שימושים רבים ומגוונים, ופרט לתחום החברתי-כלכלי ניתן למצוא אותה בתחומים כמו גרפיקה ממוחשבת, רובוטיקה, פיזיקה, וביולוגיה, וכן במגוון צורות בטבע, כפי שניתן לראות למשל בתמונות הבאות. TODO

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d4ux5d4ux5e7ux5d3ux5deux5d4-ux5dcux5e4ux5e8ux5e7-7-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-147148.}{%
\subsubsection*{קראו את ההקדמה לפרק 7 בספר הלימוד (עמודים 147־148).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5d4ux5d4ux5e7ux5d3ux5deux5d4-ux5dcux5e4ux5e8ux5e7-7-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-147148.}}
\addcontentsline{toc}{subsubsection}{קראו את ההקדמה לפרק 7 בספר הלימוד (עמודים 147־148).}

\hypertarget{ux5d4ux5d2ux5d3ux5e8ux5d4-ux5d5ux5eaux5dbux5d5ux5e0ux5d5ux5ea-ux5d1ux5e1ux5d9ux5e1ux5d9ux5d5ux5ea}{%
\section{הגדרה ותכונות בסיסיות}\label{ux5d4ux5d2ux5d3ux5e8ux5d4-ux5d5ux5eaux5dbux5d5ux5e0ux5d5ux5ea-ux5d1ux5e1ux5d9ux5e1ux5d9ux5d5ux5ea}}

\hypertarget{ux5d4ux5d2ux5d3ux5e8ux5d4}{%
\subsection{הגדרה}\label{ux5d4ux5d2ux5d3ux5e8ux5d4}}

תהי \(P=(p_1,\dots,p_n)\) קבוצה של \(n\) נקודות במישור.

\ul{\textbf{הגדרה}: דיאגרמת וורונוי}\\
דיאגרמת וורונוי של הקבוצה \(P\) היא חלוקה של המישור ל-\(n\) תאים, אחד לכל נקודה של \(P\), כך שנקודה \(q\) שייכת לתא שמתאים לנקודה \(p_i\) אם ורק אם \(\|p_i-q\|<\|p_j-q\|\) לכל \(p_j\in P\), \(j\neq i\).

נסמן ב-\(\text{Vor(P)}\) את דיאגרמת וורונוי של הקבוצה \(P\), ועבור נקודה \(p_i\in P\) נסמן ב-\(\mathcal{V}(p_i)\) את התא בדיאגרמה המתאים ל-\(p_i\).

נניח שנתונות לנו שתי נקודות בלבד, \(p_1,p_2\). כיצד תראה הדיאגרמה במקרה זה?

נתבונן באנך האמצעי לקטע \(\overline{p_1p_2}\). אנך זה נקרא ה-bisector של \(p_1\) ו-\(p_2\). כל נקודה הנמצאת על ה-bisector היא במרחק שווה מ-\(p_1\) ו-\(p_2\).

ה-bisector של \(p_1\) ו-\(p_2\) מחלק את המישור לשני חצאי מישור. נסמן ב-\(h(p_1,p_2)\) את חצי המישור הפתוח שמכיל את \(p_1\). כל נקודה הנמצאת ב-\(h(p_1,p_2)\), קרובה יותר ל-\(p_1\) מאשר ל-\(p_2\).

\hypertarget{ux5eaux5dbux5d5ux5e0ux5d5ux5ea-ux5d4ux5d3ux5d9ux5d0ux5d2ux5e8ux5deux5d4}{%
\subsection{תכונות הדיאגרמה}\label{ux5eaux5dbux5d5ux5e0ux5d5ux5ea-ux5d4ux5d3ux5d9ux5d0ux5d2ux5e8ux5deux5d4}}

\hypertarget{ux5dbux5d9ux5e6ux5d3-ux5e0ux5e8ux5d0ux5d4-ux5eaux5d0-ux5d5ux5d5ux5e8ux5d5ux5e0ux5d5ux5d9}{%
\subsubsection*{כיצד נראה תא וורונוי?}\label{ux5dbux5d9ux5e6ux5d3-ux5e0ux5e8ux5d0ux5d4-ux5eaux5d0-ux5d5ux5d5ux5e8ux5d5ux5e0ux5d5ux5d9}}
\addcontentsline{toc}{subsubsection}{כיצד נראה תא וורונוי?}

האבחנות שראינו למעלה מובילות אותנו לאבחנה הבאה לגבי המבנה של תא בדיאגרמת וורונוי:

\ul{\textbf{אבחנה}:} תא וורונוי \(\mathcal{V}(p_i)\) מתקבל על ידי חיתוך של \(n-1\) חצאי מישורים, ולכן הוא פוליגון קמור (יתכן שאינו חסום) בעל לכל היותר \(n-1\) קודקודים ו-\(n-1\) צלעות.

\hypertarget{ux5dbux5d9ux5e6ux5d3-ux5e0ux5e8ux5d0ux5d9ux5ea-ux5d4ux5d3ux5d9ux5d0ux5d2ux5e8ux5deux5d4-ux5dbux5d5ux5dcux5d4}{%
\subsubsection*{כיצד נראית הדיאגרמה כולה?}\label{ux5dbux5d9ux5e6ux5d3-ux5e0ux5e8ux5d0ux5d9ux5ea-ux5d4ux5d3ux5d9ux5d0ux5d2ux5e8ux5deux5d4-ux5dbux5d5ux5dcux5d4}}
\addcontentsline{toc}{subsubsection}{כיצד נראית הדיאגרמה כולה?}

מכיוון שכל תא בדיאגרמה הוא חיתוך של חצאי מישורים, דיאגרמת וורונוי תהיה חלוקה של המישור שהצלעות שלה הן ישרים, חצאי ישרים, או קטעים. צלעות שהן ישרים (כלומר כאלו שאינן חסומות משני הצדדים) יתקבלו רק במקרה בו כל הנקודות נמצאות על ישר אחד. בספר תראו את ההוכחה המלאה למשפט הבא:

\ul{\textbf{משפט}:} אם כל נקודות \(P\) נמצאות על ישר אחד אז \(\text{Vor(P)}\) מורכבת מ-\(n-1\) ישרים מקבילים. אחרת, \(\text{Vor(P)}\) היא גרף קשיר, והצלעות שלה הן קטעים או חצאי ישרים (קרניים).

\hypertarget{ux5e1ux5d9ux5d1ux5d5ux5dbux5d9ux5d5ux5ea-ux5d4ux5d3ux5d9ux5d0ux5d2ux5e8ux5deux5d4.}{%
\subsubsection*{סיבוכיות הדיאגרמה.}\label{ux5e1ux5d9ux5d1ux5d5ux5dbux5d9ux5d5ux5ea-ux5d4ux5d3ux5d9ux5d0ux5d2ux5e8ux5deux5d4.}}
\addcontentsline{toc}{subsubsection}{סיבוכיות הדיאגרמה.}

שימו לב שהסיבוכיות של תא בודד בדיאגרמה עשויה להיות \(\Theta(n)\), כמו למשל באיור הבא.

מה הסיבוכיות של כל הדיאגרמה? על ידי שימוש בנוסחת אוילר, והעובדה שהדרגה המינימלית של קודקוד בדיאגרמה היא 3, ניתן להוכיח שהסיבוכיות של \(\text{Vor}(P)\) היא \(O(n)\) (ההוכחה המלאה מופיעה בספר הלימוד).

\ul{\textbf{משפט}:} הסיבוכיות של \(\text{Vor(P)}\) היא \(O(n)\).

\hypertarget{ux5eaux5dbux5d5ux5e0ux5ea-ux5d4ux5deux5e2ux5d2ux5dc-ux5d4ux5e8ux5d9ux5e7.}{%
\subsubsection*{תכונת המעגל הריק.}\label{ux5eaux5dbux5d5ux5e0ux5ea-ux5d4ux5deux5e2ux5d2ux5dc-ux5d4ux5e8ux5d9ux5e7.}}
\addcontentsline{toc}{subsubsection}{תכונת המעגל הריק.}

תכונת המעגל הריק מאפשרת לנו להבין טוב יותר מיהם האנכים האמצעיים שנקודת החיתוך ביניהם היא קודקוד של הדיאגרמה. עבור נקודה \(q\), נגדיר את \(C_P(q)\) להיות המעגל הגדול ביותר שמרכזו ב-\(q\) והוא ריק (בפנימו) מנקודות \(P\). המשפט הבא הוא אפיון חשוב של דיאגרמת וורונוי, שיאפשר לנו בהמשך לבנות אותה ביעילות. ההוכחה המלאה מופיעה כמובן בספר הלימוד.

\ul{\textbf{משפט}:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  נקודה \(q\) היא קודקוד של \(\text{Vor(P)}\) אם ורק אם \(C_P(q)\) מכיל לפחות שלוש נקודות של \(P\) על שפתו.
\item
  ה-bisector של \(p_i\) ו-\(p_j\) מגדיר צלע של \(\text{Vor(P)}\) אם ורק אם קיימת נקודה \(q\) על ה-bisector כך ש-\(C_P(q)\) מכיל את \(p_i\) ו-\(p_j\) על שפתו, ואינו מכיל אף נקודה אחרת של \(P\) על שפתו.
\end{enumerate}

לפני שתעברו לחלק הבא, נסו לחשוב בעצמכם על אלגוריתם פשוט לבניית דיאגרמת וורונוי.

(רמז)

ניתן להשתמש באבחנה לגבי המבנה של תא וורונוי.

\hypertarget{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-7.1-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-148151.}{%
\subsubsection*{קראו את סעיף 7.1 בספר הלימוד (עמודים 148־151).}\label{ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-7.1-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-148151.}}
\addcontentsline{toc}{subsubsection}{קראו את סעיף 7.1 בספר הלימוד (עמודים 148־151).}

\hypertarget{ux5d7ux5d9ux5e9ux5d5ux5d1-ux5d4ux5d3ux5d9ux5d0ux5d2ux5e8ux5deux5d4}{%
\section{חישוב הדיאגרמה}\label{ux5d7ux5d9ux5e9ux5d5ux5d1-ux5d4ux5d3ux5d9ux5d0ux5d2ux5e8ux5deux5d4}}

\hypertarget{ux5e1ux5e8ux5d9ux5e7ux5ea-ux5e7ux5d5-ux5d4ux5d7ux5d5ux5e3}{%
\subsection{סריקת קו החוף}\label{ux5e1ux5e8ux5d9ux5e7ux5ea-ux5e7ux5d5-ux5d4ux5d7ux5d5ux5e3}}

האבחנה שראינו בחלק הקודם לגבי המבנה של תא וורונוי מובילה לאלגוריתם פשוט למדי לחישוב הדיאגרמה. נוכל לחשב לכל אתר \(p_i\) את החיתוך של חצאי המישורים \(h(p_i,p_j)\) לכל \(j\neq i\) בעזרת האלגוריתם שראינו בפרק 4, וכך נקבל את התא המתאים ל-\(p_i\). כך החישוב של כל תא יהיה בזמן \(O(n\log n)\), וסך כל זמן הריצה יהיה \(O(n^2 \log n)\). האם ניתן להשיג זמן טוב יותר? אחרי הכל, הסיבוכיות של דיאגרמת וורונוי היא לינארית\ldots.
בסרטון הבא נראה איך ניתן לחשב את דיאגרמת וורונוי בזמן \(O(n\log n)\) בלבד, בעזרת אלגוריתם סורק.

\hypertarget{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0.-5}{%
\subsubsection{צפו בסרטון הבא.}\label{ux5e6ux5e4ux5d5-ux5d1ux5e1ux5e8ux5d8ux5d5ux5df-ux5d4ux5d1ux5d0.-5}}

\hypertarget{ux5d4ux5d0ux5dcux5d2ux5d5ux5e8ux5d9ux5eaux5dd-ux5d4ux5e1ux5d5ux5e8ux5e7-ux5e9ux5dc-fortune}{%
\subsection{האלגוריתם הסורק של Fortune}\label{ux5d4ux5d0ux5dcux5d2ux5d5ux5e8ux5d9ux5eaux5dd-ux5d4ux5e1ux5d5ux5e8ux5e7-ux5e9ux5dc-fortune}}

בסעיף 7.2 של ספר הלימוד מתואר בפירוט האלגוריתם הסורק של Fortune לבניית דיאגרמת וורונוי. זהו אלגוריתם בסיסי וחשוב ביותר בתחום הגאומטריה חישובית. בקורס זה לא ניכנס לפרטים של האלגוריתם, ונסתפק בתיאור הרעיון הכללי שראינו קודם, ובציטוט המשפט הבא:

\ul{\textbf{משפט}:} ניתן לחשב את דיאגרמת וורונוי של קבוצת נקודות בגודל \(n\) בזמן \(O(n\log(n)\).

\hypertarget{ux5d4ux5d3ux5d2ux5deux5d4.}{%
\subsubsection*{הדגמה.}\label{ux5d4ux5d3ux5d2ux5deux5d4.}}
\addcontentsline{toc}{subsubsection}{הדגמה.}

הסרטון הבא (מאת Kevin Schaal) מציג אנימציה המדגימה את פעולת האלגוריתם:

\hypertarget{ux5dcux5deux5e2ux5d5ux5e0ux5d9ux5d9ux5e0ux5d9ux5dd-ux5d1ux5e4ux5e8ux5d8ux5d9-ux5d4ux5d0ux5dcux5d2ux5d5ux5e8ux5d9ux5eaux5dd-ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-7.2-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-151159.}{%
\subsubsection*{למעוניינים בפרטי האלגוריתם: קראו את סעיף 7.2 בספר הלימוד (עמודים 151־159).}\label{ux5dcux5deux5e2ux5d5ux5e0ux5d9ux5d9ux5e0ux5d9ux5dd-ux5d1ux5e4ux5e8ux5d8ux5d9-ux5d4ux5d0ux5dcux5d2ux5d5ux5e8ux5d9ux5eaux5dd-ux5e7ux5e8ux5d0ux5d5-ux5d0ux5ea-ux5e1ux5e2ux5d9ux5e3-7.2-ux5d1ux5e1ux5e4ux5e8-ux5d4ux5dcux5d9ux5deux5d5ux5d3-ux5e2ux5deux5d5ux5d3ux5d9ux5dd-151159.}}
\addcontentsline{toc}{subsubsection}{למעוניינים בפרטי האלגוריתם: קראו את סעיף 7.2 בספר הלימוד (עמודים 151־159).}

\hypertarget{ux5d4ux5e8ux5d7ux5d1ux5d5ux5ea}{%
\section{הרחבות}\label{ux5d4ux5e8ux5d7ux5d1ux5d5ux5ea}}

בחלקים הקודמים הגדרנו את דיאגרמת וורונוי עבור אוסף של נקודות במישור תחת מטריקת \(L_2\), כלומר, המרחק האוקלידי. אך הרעיון של דיאגרמת וורונוי הוא הרבה יותר כללי ומופשט: זוהי דיאגרמה המתארת חלוקה של המרחב לתאים לפי המרחק לאובייקטים מאוסף נתון. בחלק זה נציג בקצרה מספר הכללות והרחבות ידועות של דיאגרמת וורונוי.

\hypertarget{ux5deux5d8ux5e8ux5d9ux5e7ux5d5ux5ea-ux5d0ux5d7ux5e8ux5d5ux5ea}{%
\subsubsection{מטריקות אחרות}\label{ux5deux5d8ux5e8ux5d9ux5e7ux5d5ux5ea-ux5d0ux5d7ux5e8ux5d5ux5ea}}

מטריקה כללית
למשל מטריקת L\_1

\hypertarget{ux5d0ux5d5ux5d1ux5d9ux5d9ux5e7ux5d8ux5d9ux5dd-ux5d0ux5d7ux5e8ux5d9ux5dd}{%
\subsubsection{אובייקטים אחרים}\label{ux5d0ux5d5ux5d1ux5d9ux5d9ux5e7ux5d8ux5d9ux5dd-ux5d0ux5d7ux5e8ux5d9ux5dd}}

למשל מימדים גבוהים יותר
דיאגרמות וורונוי של קטעים

\hypertarget{ux5d4ux5d2ux5d3ux5e8ux5d5ux5ea-ux5d0ux5d7ux5e8ux5d5ux5ea}{%
\subsubsection{הגדרות אחרות}\label{ux5d4ux5d2ux5d3ux5e8ux5d5ux5ea-ux5d0ux5d7ux5e8ux5d5ux5ea}}

דיאגרמת וורונוי מסדר- k (והנקודה הרחוקה ביותר)
דיאגרמת וורונוי ממושקלת

  \bibliography{book.bib,packages.bib}

\end{document}
