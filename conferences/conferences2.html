<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computational Geometry Conferences</title>
    <style>
    /* ... (same styles as before, plus a bit extra) ... */
    body { font-family: sans-serif; margin: 20px; }
    h1 { text-align: center; margin-bottom: 20px; }
    h2 { margin-top: 30px; margin-bottom: 10px; } /* For section headings */
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background-color: #f2f2f2; }
    tr:nth-child(even) { background-color: #f9f9f9; }
    a { color: blue; text-decoration: none; }
    a:hover { text-decoration: underline; }
    .loading { text-align: center; font-style: italic; }
	/* Keep Event, Location and website, hide others */
    @media (max-width: 768px) {
        table { font-size: 14px; }
        th, td { padding: 5px; }
        th:not(:nth-child(1)):not(:nth-child(2)):not(:nth-child(8)),
        td:not(:nth-child(1)):not(:nth-child(2)):not(:nth-child(8)) { display: none; }
        table { display: block; overflow-x: auto; white-space: nowrap; }
    }
    </style>
</head>
<body>
    <h1>Computational Geometry Conferences</h1>

    <p class="loading">Loading conference data...</p>

    <h2>Future Deadlines</h2>
    <table id="futureDeadlinesTable">
        <thead><tr></tr></thead>
        <tbody></tbody>
    </table>

    <h2>Past Deadlines, Future Dates</h2>
    <table id="pastDeadlinesFutureDatesTable">
        <thead><tr></tr></thead>
        <tbody></tbody>
    </table>

    <h2>Past Deadlines, Past Dates</h2>
    <table id="pastDeadlinesPastDatesTable">
        <thead><tr></tr></thead>
        <tbody></tbody>
    </table>

    <script>
    async function fetchAndDisplayConferences() {
        const sheetId = "11Jggxd8R_U6fuJaeA1CJVpLK5R63ikHYlbaT2eF9B0A";
        const gid = '0';
        const url = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:json&gid=${gid}`;

        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const text = await response.text();
            const json = parseGoogleSheetsJSONP(text);

            const tableData = json.table;
            const headers = tableData.cols.map(col => col.label);

            // Create a mapping of column IDs to their indices
            const colIdToIndex = {};
            tableData.cols.forEach((col, index) => {
                colIdToIndex[col.id] = index;
            });

            // --- Populate table HEADERS (only once, for all tables) ---
            const headerRowFuture = document.querySelector("#futureDeadlinesTable thead tr");
            const headerRowPastFuture = document.querySelector("#pastDeadlinesFutureDatesTable thead tr");
            const headerRowPastPast = document.querySelector("#pastDeadlinesPastDatesTable thead tr");

            headers.forEach(header => {
                const th = document.createElement("th");
                th.textContent = header;
                headerRowFuture.appendChild(th);
                // Clone the header for the other tables
                headerRowPastFuture.appendChild(th.cloneNode(true));
                headerRowPastPast.appendChild(th.cloneNode(true));
            });
            // --- Populate table BODIES (separately) ---
            const tableBodyFuture = document.querySelector("#futureDeadlinesTable tbody");
            const tableBodyPastFuture = document.querySelector("#pastDeadlinesFutureDatesTable tbody");
            const tableBodyPastPast = document.querySelector("#pastDeadlinesPastDatesTable tbody");


            tableData.rows.forEach(row => {

                // Helper function to get cell data by column ID and handle date parsing
                function getCell(colId) {
                    const colIndex = colIdToIndex[colId];
                     if (colIndex !== undefined && row.c[colIndex]) {
                        const cell = row.c[colIndex];
                         if (cell.v && typeof cell.v === 'string' && cell.v.startsWith('Date(')) {
                            // Parse the date string
                            const dateParts = cell.v.substring(5, cell.v.length - 1).split(',');
                            return new Date(dateParts[0], dateParts[1], dateParts[2]);
                        }
                        return cell.f ? cell.f : cell.v; // Prefer formatted (.f) value
                    }
                    return "";
                }

                // --- Get the relevant dates (parsed as Date objects) ---
                const deadline = getCell("C");
                const conferenceDate = getCell("F");


                // --- Determine which table the row belongs in ---
                const now = new Date();
                now.setHours(0, 0, 0, 0); // Normalize 'now' to midnight for accurate comparison
                let targetTableBody;

                if (deadline instanceof Date && deadline > now) {
                    targetTableBody = tableBodyFuture;
                } else if (deadline instanceof Date && deadline <= now && conferenceDate && typeof conferenceDate === "string")
                {
                    const yearMatch = conferenceDate.match(/\b(\d{4})\b/);
					if(yearMatch){
						const year = parseInt(yearMatch[1], 10);
                        const conferenceDateObj = new Date(year, 0); // Assume January 1st if no month given

						if(conferenceDateObj > now)
                        {
                            targetTableBody = tableBodyPastFuture;
                        }
						else{
							targetTableBody = tableBodyPastPast;
						}
					}
					else{
						targetTableBody = tableBodyPastPast;
					}
                }
				else {
                    targetTableBody = tableBodyPastPast;  // Default: Past deadlines, past dates
                }

                // --- Create the table row (same as before, but added to the correct table) ---
                const tr = document.createElement("tr");

               // Event (with link from name)
                const eventTd = document.createElement("td");
                const eventName = getCell("A");
                const colIndexH = colIdToIndex["H"];

                if (colIndexH !== undefined && row.c[colIndexH] && row.c[colIndexH].v && row.c[colIndexH].v.startsWith("http")) {
                    const a = document.createElement("a");
                     a.href =  row.c[colIndexH].v; // Use the RAW value for the URL
                    a.textContent = eventName;
                    a.target = "_blank";
                    eventTd.appendChild(a);
                } else {
                    eventTd.textContent = eventName;
                }
                tr.appendChild(eventTd);

                // Other columns
                tr.appendChild(createTd(getCell("B")));  // Location
                tr.appendChild(createTd(getCell("C") instanceof Date ? getCell("C").toLocaleDateString() : getCell("C")));  // Deadline
                tr.appendChild(createTd(getCell("D") instanceof Date ? getCell("D").toLocaleDateString() : getCell("D")));   // Abstract
                tr.appendChild(createTd(getCell("E") instanceof Date ? getCell("E").toLocaleDateString() : getCell("E")));   // Notification
                tr.appendChild(createTd(getCell("F")));  // Date
                tr.appendChild(createTd(getCell("G")));  // Comments

                // Website Column (separate) - THE KEY ADDITION
                const websiteTd = document.createElement("td");
                if (colIndexH !== undefined && row.c[colIndexH] && row.c[colIndexH].v && row.c[colIndexH].v.startsWith("http")) {
                    const a = document.createElement("a");
                    a.href = row.c[colIndexH].v; // Raw URL
                    a.textContent = "Link";       // Display "Link" (or anything you want)
                    a.target = "_blank";
                    websiteTd.appendChild(a);
                } // No "else" needed - leave the cell empty if no link
                tr.appendChild(websiteTd);


                tr.appendChild(createTd(getCell("I")));  // Countdown
                tr.appendChild(createTd(getCell("J")));  // (for sorting)

                targetTableBody.appendChild(tr); // Add the row to the correct table
            });

            document.querySelector(".loading").style.display = "none";

        } catch (error) {
            console.error("Error fetching or parsing data:", error);
            document.querySelector(".loading").textContent = "Error loading conference data. Please try again later.";
        }
    }
		// Helper function to create table cells
	function createTd(content) {
		const td = document.createElement("td");
		td.textContent = content || ""; // Ensure content is not null/undefined
		return td;
	}

    // Handles the "/*O_o*/" prefix.
    function parseGoogleSheetsJSONP(text) {
        const jsonString = text.replace(/^\/\*O_o\*\/\s*/, '').replace(/google\.visualization\.Query\.setResponse\(|\);/g, "");
        return JSON.parse(jsonString);
    }

    fetchAndDisplayConferences();
    </script>
</body>
</html>