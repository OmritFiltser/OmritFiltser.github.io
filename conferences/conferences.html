<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Computational Geometry Conferences</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f9;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        h2 {
            margin-top: 30px;
            padding-bottom: 5px;
            border-bottom: 2px solid #ccc;
        }
        #future_deadline h2 { color: #007bff; } /* Blue */
        #future_nodl h2 { color: #ffc107; } /* Yellow */
        #past h2 { color: #d9534f; } /* Red */

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            background-color: white;
            font-size: 0.9em; 
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px; 
            text-align: left;
        }
        th {
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
        }
        #future_deadline th { background-color: #007bff; }
        #future_nodl th { background-color: #ffc107; color: #333; }
        #past th { background-color: #d9534f; }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        /* --- NEW CSS FOR HOVER EFFECT --- */
        tr:hover {
            background-color: #e0e0e0; /* A soft gray for highlighting */
            cursor: pointer; /* Optional: Changes cursor to pointer */
        }
        /* Ensure even rows still highlight */
        tr:nth-child(even):hover {
            background-color: #e0e0e0; 
        }
        /* --- END NEW CSS --- */
        .loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2em;
            color: #555;
        }
        .error {
            color: red;
            font-weight: bold;
            text-align: center;
        }
        .comments-col {
            font-style: italic;
            font-size: 0.85em;
        }
    </style>
</head>
<body>

    <h1>Computational Geometry Conferences</h1>

    <div id="loading" class="loading">Loading conference data...</div>

    <div id="future_deadline">
        <h2>Conferences with Future Deadline ‚è≥</h2>
        <table id="table_future_deadline"></table>
    </div>

    <div id="future_nodl">
        <h2>Upcoming Conferences (Deadline Passed) üìÖ</h2>
        <table id="table_future_nodl"></table>
    </div>

    <div id="past">
        <h2>Past Conferences archives üìö</h2>
        <table id="table_past"></table>
    </div>

    <script>
        // --- 1. Configuration ---
        const SHEET_ID = '11Jggxd8R_U6fuJaeA1CJVpLK5R63ikHYlbaT2eF9B0A';
        const GID = '0'; // Assumes the first sheet (tab).
        const CALLBACK_NAME = 'handleGvizQueryResponse';
        const API_BASE_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?gid=${GID}`;
        
        // --- 2. Utility Functions ---
        
        // Helper to parse the original Google Sheets Date object string: Date(YYYY, M-1, DD)
        const parseSheetDate = (cellValue) => {
            if (!cellValue) return null;
            
            // 1. Check for the Google Sheets 'Date(YYYY, M-1, DD)' format
            if (cellValue.startsWith('Date(')) {
                const parts = cellValue.match(/Date\((\d+),(\d+),(\d+)\)/);
                if (parts) {
                    // MONTH is 0-indexed in Google Sheets format
                    return new Date(Date.UTC(parts[1], parts[2], parts[3]));
                }
            }

            // 2. Fallback for standard ISO or simple strings (using UTC for consistency)
            const isoDateString = cellValue.includes('T') ? cellValue : `${cellValue}T00:00:00Z`;
            const date = new Date(isoDateString);
            
            if (!isNaN(date) && date.getFullYear() > 1900) {
                 return date;
            }

            return null; 
        };

        // Utility function to format a single date for display
        const formatDate = (dateString) => {
            if (!dateString) return 'N/A';
            const date = parseSheetDate(dateString);
            if (date && !isNaN(date)) {
                return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric', timeZone: 'UTC' });
            }
            return 'N/A';
        };

        // Utility function to format date range
        const formatConfDates = (startStr, endStr) => {
            const startDate = parseSheetDate(startStr);
            const endDate = parseSheetDate(endStr);

            if (!startDate) return 'TBA';
            
            const startDay = startDate.getUTCDate();
            const endDay = endDate ? endDate.getUTCDate() : null;
            const monthYear = startDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long', timeZone: 'UTC' });
            
            if (!endDate || startDate.getTime() === endDate.getTime()) {
                // Single day or end date missing
                return `${startDay} ${monthYear}`;
            }

            // Check if month/year are the same
            if (startDate.getUTCFullYear() === endDate.getUTCFullYear() && startDate.getUTCMonth() === endDate.getUTCMonth()) {
                return `${startDay}-${endDay} ${monthYear}`;
            }

            // Different months/years (fallback to standard display for complexity)
            return `${formatDate(startStr)} - ${formatDate(endStr)}`;
        };

        // Function to create the HTML table rows
        const createTable = (data, elementId) => {
            const table = document.getElementById(elementId);
            // Define headers based on the new desired order
            const HEADERS = [
                "Conference", "Location", "Submission Deadline", "Notification Date", "Conference Dates", "Comments", "Website"
            ];

            if (!data.length) {
                table.innerHTML = `<thead><tr>${HEADERS.map(h => `<th>${h}</th>`).join('')}</tr></thead><tbody><tr><td colspan="${HEADERS.length}">No conferences found in this category.</td></tr></tbody>`;
                return;
            }

            const headerHtml = `<thead><tr>${HEADERS.map(h => `<th>${h}</th>`).join('')}</tr></thead>`;
            
            const rows = data.map(item => {
                const [name, location, deadline, abstractDL, notification, confStart, confEnd, comments, websiteLinkText, linkURL] = item;
                
                // Prepare formatted data
                const confDatesStr = formatConfDates(confStart, confEnd);

                let dlDisplay = formatDate(deadline);
                if (abstractDL) {
                    const abstractDisplay = formatDate(abstractDL);
                    if (abstractDisplay !== 'N/A') {
                        dlDisplay += ` (<span style="white-space: nowrap;">Abstract: ${abstractDisplay}</span>)`;
                    }
                }
                
                const notificationDisplay = formatDate(notification);
                const linkHtml = linkURL && websiteLinkText ? `<a href="${linkURL}" target="_blank">${websiteLinkText}</a>` : 'N/A';
                const commentsDisplay = comments || '';


                return `
                    <tr>
                        <td>${name}</td>
                        <td>${location || 'TBA'}</td>
                        <td>${dlDisplay}</td>
                        <td>${notificationDisplay}</td>
                        <td>${confDatesStr}</td>
                        <td class="comments-col">${commentsDisplay}</td>
                        <td>${linkHtml}</td>
                    </tr>
                `;
            }).join('');

            table.innerHTML = headerHtml + `<tbody>${rows}</tbody>`;
        };
        
        // --- 3. Main Data Handler (JSONP Callback) ---

        window[CALLBACK_NAME] = (response) => {
            try {
                if (response.status !== 'ok') {
                     throw new Error(response.errors.map(e => e.message).join(', ') || 'Unknown error fetching data.');
                }
                
                const rows = response.table.rows;
                
                // Define 'today' consistently as midnight UTC (for accurate filtering)
                const now = new Date();
                const year = now.getUTCFullYear();
                const month = now.getUTCMonth();
                const date = now.getUTCDate();
                const todayUTC = new Date(Date.UTC(year, month, date)); 

                const futureDeadline = [];
                const futureNoDL = [];
                const past = [];

                rows.forEach(row => {
                    const cells = row.c; 
                    
                    // --- MAPPING BASED ON YOUR COLUMN LIST (Indices remain the same) ---
                    // A: Conference Name (Index 0)
                    const name = cells[0] ? (cells[0].v || cells[0].f) : null;
                    // B: Location (Index 1)
                    const location = cells[1] ? (cells[1].v || cells[1].f) : null;
                    // C: Deadline (Index 2)
                    const deadlineDateStr = cells[2] ? cells[2].v : null; 
                    // D: Abstract Deadline (Index 3)
                    const abstractDateStr = cells[3] ? cells[3].v : null; 
                    // E: Notification (Index 4)
                    const notificationDateStr = cells[4] ? cells[4].v : null; 
                    // F: Conference Start Date (Index 5) - Used for filtering
                    const confStartStr = cells[5] ? cells[5].v : null; 
                    // G: Conference End Date (Index 6)
                    const confEndStr = cells[6] ? cells[6].v : null;
                    // H: Comments (Index 7)
                    const comments = cells[7] ? (cells[7].v || cells[7].f) : null;
                    // I: Website Link Text (Index 8)
                    const websiteLinkText = cells[8] ? (cells[8].v || cells[8].f) : null;
                    // J: Website Link URL (Index 9)
                    const linkURL = cells[9] ? (cells[9].v || cells[9].f) : null;
                    
                    // Skip if key data is missing (using Conference Start Date for filtering)
                    if (!name || !confStartStr) return; 

                    // Parse dates (returns midnight UTC)
                    const confDate = parseSheetDate(confStartStr);
                    const deadlineDate = deadlineDateStr ? parseSheetDate(deadlineDateStr) : null;
                    
                    if (!confDate) {
                        console.warn(`Skipping row with unparsable Conference Start Date: ${name}. Raw value: ${confStartStr}`);
                        return; 
                    }
                    
                    // The item array holds ALL the raw strings/values for display
                    const item = [name, location, deadlineDateStr, abstractDateStr, notificationDateStr, confStartStr, confEndStr, comments, websiteLinkText, linkURL];

                    // 1. PAST Conferences (Conference Date is strictly before Today UTC)
                    if (confDate < todayUTC) {
                        past.push(item);
                        return;
                    }

                    // 2. FUTURE Conferences (Conference Date is Today UTC or Later)
                    
                    // A. Conferences with FUTURE Deadline (Deadline is Today UTC or Later)
                    if (deadlineDate && deadlineDate >= todayUTC) {
                        futureDeadline.push(item);
                        return;
                    }
                    
                    // B. Upcoming Conferences (Deadline Passed or N/A)
                    if (confDate >= todayUTC) {
                         futureNoDL.push(item);
                         return;
                    }
                });

                // Sorting logic
                // Helper for sorting
                const sortByDate = (a, b, index, reverse = false) => {
                    // a[index] and b[index] hold the raw date strings
                    const dateA = parseSheetDate(a[index]);
                    const dateB = parseSheetDate(b[index]);
                    // Handle missing dates by pushing them to the end (A.T.M. means A goes after B)
                    if (!dateA && !dateB) return 0;
                    if (!dateA) return 1; 
                    if (!dateB) return -1;
                    return reverse ? (dateB - dateA) : (dateA - dateB);
                };
                
                // Future tables sorted by Conference Start Date (Index 5)
                futureDeadline.sort((a, b) => sortByDate(a, b, 5));
                futureNoDL.sort((a, b) => sortByDate(a, b, 5));

                // Past conferences sorted by Submission Deadline (Index 2) from OLDEST to NEWEST
                past.sort((a, b) => sortByDate(a, b, 2, false)); 

                // Render the tables
                createTable(futureDeadline, 'table_future_deadline');
                createTable(futureNoDL, 'table_future_nodl');
                createTable(past, 'table_past');

            } catch (error) {
                console.error('Error processing conference data:', error);
                const loadingDiv = document.getElementById('loading');
                loadingDiv.className = 'error';
                loadingDiv.textContent = `CRITICAL ERROR: Could not process data. Details: ${error.message}.`;
                return;
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        };

        // --- 4. Initialization ---

        const fetchConferences = () => {
            // Final URL includes JSONP bypass, but no TQ query
            const finalUrl = `${API_BASE_URL}&tqx=reqId:0;out:json;responseHandler:${CALLBACK_NAME}`;
            
            const script = document.createElement('script');
            script.src = finalUrl;
            script.onerror = () => {
                const loadingDiv = document.getElementById('loading');
                loadingDiv.className = 'error';
                loadingDiv.textContent = 'NETWORK ERROR: Failed to load Google Sheet data. Ensure the Sheet is "Published to the web" and the ID is correct.';
                document.getElementById('loading').style.display = 'block';
            };
            document.head.appendChild(script);
        };

        document.addEventListener('DOMContentLoaded', fetchConferences);
    </script>

</body>
</html>